'   Win2Pdf  v1.0   by Marpon      marpon@aliceadsl.fr
'       created: March 21, 2019 at 13:37:00
'       test sample to use v1.4 libPrint2Pdf_32.a / libPrint2Pdf_64.a


'------------------------------------------------------------------------------
' Original Source code generated by FireFly Visual Designer Version: 3.78
' Visit www.planetsquires.com for more information
'------------------------------------------------------------------------------

' to compile that application (via command line ...)
' replace c:\Freebasic_Path\fbc.exe by your path to fbc.exe

' ========================================================================================

' cmdline "c:\Freebasic_Path\fbc.exe" -x "Win2Pdf.exe" Win2Pdf.bas -s gui -v Win2Pdf.rc > Win2Pdf.log 2>&1

' ========================================================================================

'needed files to compile :
'	this file and print2pdf.bi ; Win2Pdf.rc ; Win2Pdf.Exe.Manifest ; Win2Pdf.ico (have them in the same folder as Win2Pdf.bas)
'   and static lib version 1.4: libPrint2Pdf_32.a or libPrint2Pdf_64.a, depending on 32/64 compiler (have in the same folder as Win2Pdf.bas or in inc folder)


'CSED_FB : meta-cmds used by CSED_FB editor only to define name and rc file to use, seen as comments by compiler.
_:[CSED_COMPIL_NAME]:  Win2Pdf.exe
_:[CSED_COMPIL_RC]:    Win2Pdf.rc

#Define  __NAME_APPLI_VERSION__  "Win2Pdf  V: 1.0"   ' change here if you want change the title of main window

#Include Once "windows.bi"
#Include Once "win\commdlg.bi"
#Include Once "win\shlobj.bi"

#Include Once ".\print2pdf.bi"

Dim Shared extended as Long

' ========================================================================================
Dim Shared gFLY_AppID As zString * MAX_PATH
Dim Shared gFLY_FontHandles() As HFONT
Dim Shared gFLY_hDlgCurrent As HWND


#Define DQ 34                                    ' double quote

#if __FB_VERSION__ < "1.02"
    #define ENM_PARAGRAPHEXPANDED &h00000020
    #define LV_COLUMNA LVCOLUMNA
    #define LV_COLUMNW LVCOLUMNW
    #define NM_LISTVIEW NMLISTVIEW
    #define LV_ITEMA LVITEMA
    #define LV_ITEMW LVITEMW
    #define GCLP_HBRBACKGROUND GCL_HBRBACKGROUND
#endif


Type FLY_RESCALEDATA
        FormInit                   As Long       ' Form initial width or height
        FormCur                    As Long       ' Form current width or height
        P_Init                     As Long       ' Point initial value
        P_New                      As Long       ' Point newly calculated value
End Type

' Structure that holds Form/Control information
Type FLY_DATA
        OldProc                    As WNDPROC    ' address to old window procedure
        hWndControl                As HWND       ' handle of the control
        hWndParent                 As HWND       ' handle of the parent
        IsForm                     As Long       ' flag indicating that this is a Form
        IsModal                    As Long       ' flag indicating modal form
        hFont                      As HFONT      ' handle to font
        hAccel                     As HACCEL     ' handle to accelerator table
        hBackBitmap                As HBITMAP    ' handle of background form bitmap
        hStatusBarTimer            as Long       ' handle of timer for statusbar
        ControlIndex               As Long       ' controlindex of control
        CtrlFocus                  As HWND       ' control with current focus
        SelText                    As Long       ' flag to highlight text in edit controls
        ProcessCtlColor            As Long       ' flag to process color messages
        IsForeSysColor             As Long       ' flag indicating to use system color
        IsBackSysColor             As Long       ' flag indicating to use system color
        hBackBrush                 As HBRUSH     ' brush for background color
        nForeColor                 As Long       ' foreground color
        nBackColor                 As Long       ' background color
        fResizeInit                As Long       ' flag signaling that resize has been initialized
        rcForm                     As Rect       ' Rectangle holding the Form's client dimensions (resizing)
        rcCtrl                     As Rect       ' Rectangle of the control in client relative dimensions (resizing)
        zConstraints               As zString * 30 ' resize constraints
End Type

' Common info that the programmer can access via the Shared APP variable.
Type APP_TYPE
        Comments                   As zString * MAX_PATH ' Comments
        CompanyName                As zString * MAX_PATH ' Company Name
        EXEName                    As zString * MAX_PATH ' EXE name of program
        FileDescription            As zString * MAX_PATH ' File Description
        hInstance                  As HINSTANCE          ' Instance handle of the program
        Path                       As zString * MAX_PATH ' Current Path to the EXE
        ProductName                As zString * MAX_PATH ' Product Name
        LegalCopyright             As zString * MAX_PATH ' Legal Copyright
        LegalTrademarks            As zString * MAX_PATH ' Legal Trademarks
        ProductMajor               As Long               ' Product Major number
        ProductMinor               As Long               ' Product Minor number
        ProductRevision            As Long               ' Product Revision number
        ProductBuild               As Long               ' Product Build number
        FileMajor                  As Long               ' File Major number
        FileMinor                  As Long               ' File Minor number
        FileRevision               As Long               ' File Revision number
        FileBuild                  As Long               ' File Build number
        ReturnValue                As Long               ' User value returned from FF_FormClose
End Type
Dim Shared App As APP_TYPE


Private Function FF_Remain_Internal(ByRef sMainString as String , _
            ByRef sMatchPattern as String _
            ) as String

    Dim nLenMain as Long = Len(sMainString)
    Dim i as Long

    i = InStr(sMainString , sMatchPattern)
    If i Then
        Function = Mid(sMainString , i + 1)
    Else
        Function = ""
    End If
End Function


' =====================================================================================
' Get the Windows version (based on code from Jose Roca)
' =====================================================================================
Private Function AfxGetWindowsVersion() as Single
    Dim dwVersion AS Long
    Dim nMajorVer As Long
    Dim nMinorVer As Long
    dwVersion = GetVersion
    nMajorVer = LOBYTE(LOWORD(dwVersion))
    nMinorVer = HIBYTE(LOWORD(dwVersion))
    Function = nMajorVer + (nMinorVer / 100)
End Function


' =====================================================================================
' Scales an horizontal coordinate according the DPI (dots per pixel) being used by the application.
' Based on code from Jsoe Roca
' =====================================================================================
Private Function AfxScaleX(byval cx as Single) as Single
    #IfDef FF_NOSCALE
        Function = cx
    #Else
        Dim hDC As HDC
        hDC = GetDC(Null)
        Function = cx * (GetDeviceCaps(hDC , LOGPIXELSX) / 96)
        ReleaseDC Null , hDC
    #EndIf
End Function


' =====================================================================================
' Scales a vertical coordinate according the DPI (dots per pixel) being used by the application.
' Based on code from Jose Roca
' =====================================================================================
Private Function AfxScaleY(byval cy as Single) as Single
    #IfDef FF_NOSCALE
        Function = cy
    #Else
        Dim hDC As HDC
        hDC = GetDC(Null)
        Function = cy * (GetDeviceCaps(hDC , LOGPIXELSY) / 96)
        ReleaseDC Null , hDC
    #EndIf
End Function
' =====================================================================================


' =====================================================================================
' Based on code from Jose Roca
' Creates a standard tooltip for a window's entire client area.
' Parameters:
' - hwnd = Handle to the window
' - strTooltipText = Tooltip text
' - bBalloon = Ballon tip (TRUE or FALSE)
' Return Value:
' The handle of the tooltip control
' =====================================================================================
Private Function FF_AddTooltip(BYVAL hwnd AS HWND , byref strTooltipText AS STRING , BYVAL bBalloon AS Long) As HWND

    IF hwnd = 0 Then Exit Function

    Dim hwndTT AS HWND
    Dim dwStyle As Long

    dwStyle = WS_POPUP OR TTS_NOPREFIX OR TTS_ALWAYSTIP
    IF bBalloon THEN dwStyle = dwStyle OR TTS_BALLOON
    hwndTT = CreateWindowEx(WS_EX_TOPMOST , "tooltips_class32" , "" , dwStyle , 0 , 0 , 0 , 0 , 0 , _
            Cast(HMENU , Null) , 0 , ByVal Cast(LPVOID , Null))
    IF hwndTT = 0 THEN Exit Function
    SetWindowPos(hwndTT , HWND_TOPMOST , 0 , 0 , 0 , 0 , SWP_NOMOVE OR SWP_NOSIZE OR SWP_NOACTIVATE)

    ' // Register the window with the tooltip control
    Dim tti AS TOOLINFO
    tti.cbSize = SIZEOF(tti)
    tti.uFlags = TTF_SUBCLASS
    tti.hwnd = hwnd
    tti.hinst = GetModuleHandle(BYVAL NULL)

    GetClientRect(hwnd , Varptr(tti.rect))

    ' // The length of the string must not exceed of 80 characters, including the terminating null
    IF LEN(strTooltipText) > 79 THEN strTooltipText = LEFT(strTooltipText , 79)
    tti.lpszText = STRPTR(strTooltipText)
    tti.uId = 0
    SendMessage hwndTT , TTM_ADDTOOL , 0 , Cast(LPARAM , Varptr(tti))
    Function = hwndTT

End Function


Dim Shared HWND_FORM1 As HWND
Dim Shared IDC_FORM1_COMMAND7 As Long
Dim Shared HWND_FORM1_COMMAND7 As HWND
Dim Shared IDC_FORM1_COMMAND6 As Long
Dim Shared HWND_FORM1_COMMAND6 As HWND
Dim Shared IDC_FORM1_LABEL1 As Long
Dim Shared HWND_FORM1_LABEL1 As HWND
Dim Shared IDC_FORM1_COMMAND5 As Long
Dim Shared HWND_FORM1_COMMAND5 As HWND
Dim Shared IDC_FORM1_LISTVIEW1 As Long
Dim Shared HWND_FORM1_LISTVIEW1 As HWND
Dim Shared IDC_FORM1_COMMAND3 As Long
Dim Shared HWND_FORM1_COMMAND3 As HWND
Dim Shared IDC_FORM1_COMMAND4 As Long
Dim Shared HWND_FORM1_COMMAND4 As HWND
Dim Shared IDC_FORM1_COMMAND2 As Long
Dim Shared HWND_FORM1_COMMAND2 As HWND
Dim Shared IDC_FORM1_COMMAND1 As Long
Dim Shared HWND_FORM1_COMMAND1 As HWND


Declare Function FORM1_Show(ByVal hWndParent As HWND , _
        ByVal ShowModalFlag As Long , _
        ByVal UserData As long = 0 _
        ) As HWND
Declare Sub FORM1_CreateControls(ByVal hWndForm As HWND)
Declare Function FORM1_FORMPROCEDURE(ByVal hWndForm As HWND , _
        ByVal wMsg As uInteger , _
        ByVal wParam As WPARAM , _
        ByVal lParam As LPARAM _
        ) As LRESULT
Declare Function FORM1_CODEPROCEDURE(ByVal hWndControl As HWND , _
        ByVal wMsg As uInteger , _
        ByVal wParam As WPARAM , _
        ByVal lParam As LPARAM _
        ) As LRESULT
Declare Function FORM1_WM_CREATE( _
        ByVal hWndForm as HWnd , _
        ByVal UserData as Long _
        ) as Long
Declare Function FORM1_COMMAND1_BN_CLICKED( _
        ByVal ControlIndex as Long , _
        ByVal hWndForm as HWnd , _
        ByVal hWndControl as HWnd , _
        ByVal idButtonControl as Long _
        ) as Long
Declare Function fill_array(ByRef s0 as String) as Long
Declare Function FORM1_COMMAND2_BN_CLICKED( _
        ByVal ControlIndex as Long , _
        ByVal hWndForm as HWnd , _
        ByVal hWndControl as HWnd , _
        ByVal idButtonControl as Long _
        ) as Long
Declare Function FORM1_COMMAND3_BN_CLICKED( _
        ByVal ControlIndex as Long , _
        ByVal hWndForm as HWnd , _
        ByVal hWndControl as HWnd , _
        ByVal idButtonControl as Long _
        ) as Long
Declare Function FORM1_COMMAND4_BN_CLICKED( _
        ByVal ControlIndex as Long , _
        ByVal hWndForm as HWnd , _
        ByVal hWndControl as HWnd , _
        ByVal idButtonControl as Long _
        ) as Long
Declare Sub unselect()
Declare Function FORM1_COMMAND5_BN_CLICKED( _
        ByVal ControlIndex as Long , _
        ByVal hWndForm as HWnd , _
        ByVal hWndControl as HWnd , _
        ByVal idButtonControl as Long _
        ) as Long
Declare Function FORM1_COMMAND6_BN_CLICKED( _
        ByVal ControlIndex as Long , _
        ByVal hWndForm as HWnd , _
        ByVal hWndControl as HWnd , _
        ByVal idButtonControl as Long _
        ) as Long
Declare Function FORM1_COMMAND7_BN_CLICKED( _
        ByVal ControlIndex as Long , _
        ByVal hWndForm as HWnd , _
        ByVal hWndControl as HWnd , _
        ByVal idButtonControl as Long _
        ) as Long
Declare Function FF_WINMAIN(ByVal hInstance as HINSTANCE , _
        ByVal hPrevInstance as HINSTANCE , _
        ByRef lpCmdLine as String , _
        ByVal iCmdShow as Long) as Long
Declare Function FF_PUMPHOOK(ByRef uMsg as Msg) as Long
Declare Sub FLY_InitializeVariables()
Declare Sub FLY_SetAppVariables()
Declare Function FLY_AdjustWindowRect(ByVal hWndForm As HWND , _
        ByVal cxClient As Long , _
        ByVal cyClient As Long _
        ) As Long
Declare Function FLY_EnumSysColorChangeProc(ByVal hWnd As HWND , ByVal lParam As LPARAM) As Long
Declare Function FLY_SetControlData(ByVal hWndControl As HWND , _
        ByVal AllowSubclass As Long , _
        ByVal AllowSetFont As Long , _
        ByRef sFontString As String , _
        ByVal nControlIndex As Long , _
        ByVal nProcessColor As Long , _
        ByVal IsForeSysColor As Long , _
        ByVal IsBackSysColor As Long , _
        ByVal nForeColor As Long , _
        ByVal nBackColor As Long , _
        ByVal nTransparentBrush As HBRUSH , _
        ByVal CodeProcedure As WNDPROC , _
        Byref sResizeRules As String , _
        ByVal nFontUpgrade As Long _
        ) As FLY_DATA ptr
Declare Function FLY_DoMessagePump(ByVal ShowModalFlag As Long , _
        ByVal hWndForm As HWND , _
        ByVal hWndParent As HWND , _
        ByVal nFormShowState As Long , _
        ByVal IsMDIForm As Long _
        ) As HWND
Declare Function FLY_GetActiveHandle(ByVal hWnd As HWND) as HWND
Declare Function FLY_ResizeRuleInitEnum(ByVal hWnd As HWND , ByVal lParam As LPARAM) As Long
Declare Function FLY_ResizeRuleEnum(ByVal hWnd As HWND , ByVal lParam As LPARAM) As Long
Declare Function WinMain(ByVal hInstance As HINSTANCE , _
        ByVal hPrevInstance As HINSTANCE , _
        ByRef lpCmdLine As String , _
        ByVal iCmdShow As Long _
        ) As Long
Declare Function FF_Main(ByVal hInstance As HINSTANCE , ByVal fwdReason As long) As long

Declare Function FF_Control_GetCheck(ByVal hWndControl As HWND) As Long

Declare Sub FF_Control_GetColor(ByVal hWndControl as HWnd , _
        ByRef ForeColor as Long , _
        ByRef BackColor as Long)

Declare Function FF_Control_GetTag(ByVal hWndControl As HWND) As String

Declare Function FF_Control_GetTag2(ByVal hWndControl As HWND) As String

Declare Function FF_Control_GetText(ByVal hWndControl As HWND) As String

Declare Sub FF_Control_Redraw(ByVal hWndControl As HWND)

Declare Sub FF_Control_SetCheck(ByVal hWndControl as HWnd , _
        ByVal nCheckState as Long)

Declare Sub FF_Control_SetColor(ByVal hWndControl as HWnd , _
        ByVal ForeColor as Long , _
        ByVal BackColor as Long)

Declare Sub FF_Control_SetTag(ByVal hWnd As HWND , _
        ByRef NewTag As String)

Declare Sub FF_Control_SetTag2(ByVal hWnd As HWND , _
        ByRef NewTag As String)

Declare Sub FF_Control_SetText(ByVal hWndControl As HWND , _
        ByRef TheText As String)

Declare Function FF_Control_ShowState(ByVal hWndControl As HWND , _
        ByVal nShowState As Integer _
        ) As Integer

Declare Function FF_FileName(ByRef Src As String) As String

Declare Function FF_FilePath(ByRef Src As String) As String

Declare Sub FF_CloseForm(ByVal hwndForm As HWND , _
        ByVal ReturnValue As Integer = 0)

Declare Function FF_AfxGetFontPointSize(ByVal nHeight As Long) As Long
Declare Function FF_GetFontInfo(ByRef sCurValue As String , _
        ByRef sFontName As String , _
        ByRef nPointSize As Long , _
        ByRef nWeight As Long , _
        ByRef nItalic As Long , _
        ByRef nUnderline As Long , _
        ByRef nStrikeOut As Long , _
        ByRef nFontStyle As Long _
        ) As Long
Declare Function FF_EnumCharSet( _
        ByRef elf As ENUMLOGFONT , _
        ByRef ntm As NEWTEXTMETRIC , _
        ByVal FontType As Long , _
        ByVal CharSet As Long _
        ) As Long
Declare Function FF_MakeFontEX(Byref sFont As String , _
        ByVal PointSize As Long , _
        ByVal fBold As Long , _
        ByVal fItalic As Long , _
        ByVal fUnderline As Long , _
        ByVal StrikeThru As Long _
        ) As HFONT
Declare Function FF_MakeFontEx_Internal(Byref sFont As String) As HFONT

Declare Function FF_CenterOpenFileDialog(ByVal HWnd as HWnd , _
        ByVal wMsg as UInteger , _
        ByVal wParam as WPARAM , _
        ByVal lParam as LPARAM _
        ) as Long
Declare Function FF_OpenFileDialog(ByVal HWnd as HWnd , _
        ByRef sCaption as String , _
        ByRef FileSpec as String , _
        ByRef InitialDir as String , _
        ByRef Filter As String , _
        ByRef DefExtension As String , _
        ByVal Flags As UInteger , _
        ByVal CenterFlag As Integer _
        ) As Integer

Declare Function FF_ListView_DeleteAllItems(ByVal hWndControl As HWND) As Long

Declare Function FF_ListView_DeleteItem(ByVal hWndControl as HWnd , _
        ByVal iPosition as Long _
        ) as Long

Declare Function FF_ListView_GetColumnAlignment(ByVal hWndControl as HWnd , _
        ByVal iPosition as Long _
        ) as Long

Declare Function FF_ListView_GetItemCount(ByVal hWndControl As HWND) As Long

Declare Function FF_ListView_GetItemImage(ByVal hWndControl as HWnd , _
        ByVal iRow as Long , _
        ByVal iColumn as Long _
        ) as Long

Declare Function FF_ListView_GetItemlParam(ByVal hWndControl as HWnd , _
        ByVal iRow as Long , _
        ByVal iColumn as Long) as Long

Declare Function FF_ListView_GetItemText(ByVal hWndControl as HWnd , _
        ByVal iRow as Long , _
        ByVal iColumn as Long _
        ) as String

Declare Function FF_ListView_GetSelectedItem(ByVal hWndControl As HWND) As Long

Declare Function FF_ListView_InsertColumn(ByVal hWndControl as HWnd , _
        ByVal iPosition as Long , _
        ByRef TheText as String , _
        ByVal nAlignment as Long = LVCFMT_LEFT , _
        ByVal nWidth as Long = 100 _
        ) as Integer

Declare Function FF_ListView_InsertItem(ByVal hWndControl as HWnd , _
        ByVal iRow as Long , _
        ByVal iColumn as Long , _
        ByRef TheText as String , _
        ByVal lParam as Long = 0 , _
        ByVal iImage as Long = 0 _
        ) as Integer

Declare Function FF_ListView_SetColumnAlignment(ByVal hWndControl as HWnd , _
        ByVal iPosition as Long , _
        ByVal nAlignment as Long _
        ) as Integer

Declare Function FF_ListView_SetItemImage(ByVal hWndControl as HWnd , _
        ByVal iRow as Long , _
        ByVal iColumn as Long , _
        ByVal iImage as Long _
        ) as Integer

Declare Function FF_ListView_SetItemlParam(ByVal hWndControl as HWnd , _
        ByVal iRow as Long , _
        ByVal iColumn as Long , _
        ByVal lParam as Long _
        ) as Integer

Declare Function FF_ListView_SetItemText(ByVal hWndControl as HWnd , _
        ByVal iRow as Long , _
        ByVal iColumn as Long , _
        ByRef TheText as String _
        ) as Long

Declare Function FF_ListView_SetSelectedItem(ByVal hWndControl as HWnd , _
        ByVal nIndex as Long _
        ) as Long

Declare Function FF_Parse(ByRef sMainString as String , _
        ByRef sDelimiter as String , _
        ByVal nPosition as Integer _
        ) as String

Declare Function FF_Parse_Internal(ByRef sMainString as String , _
        ByRef sDelimiter as String , _
        ByRef nPosition as Integer , _
        ByRef nIsAny as Integer , _
        ByRef nLenDelimiter as Integer _
        ) as String

Declare Function FF_Replace(ByRef sMainString As String , _
        ByRef sMatchPattern As String , _
        ByRef sReplaceWith As String _
        ) As String
Declare Function FF_ReplaceAny(ByRef sMainString As String , _
        ByRef sMatchPattern As String , _
        ByRef sReplaceWith As String _
        ) As String




Private Function FF_Control_GetCheck(ByVal hWndControl As HWND) As Long

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        ' Get the check state
        If SendMessage(hWndControl , BM_GETCHECK , 0 , 0) = BST_CHECKED Then
            Function = True
        End If

    End If

End Function

Private Sub FF_Control_GetColor(ByVal hWndControl as HWnd , _
            ByRef ForeColor as Long , _
            ByRef BackColor as Long)

    Dim ff as FLY_DATA Ptr
    Dim hBrush as HBRUSH
    Dim LOG_BRUSH as LOGBRUSH

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        ff = GetProp(hWndControl , "FLY_PTR")

        If ff Then
            ' Determine is we are dealing with a Form or Control
            If ff -> IsForm Then
                hBrush = Cast(HBRUSH , GetClassLongPtr(hWndControl , GCLP_HBRBACKGROUND))
                'Get the Color From the brush:
                GetObject hBrush , SizeOf(LOG_BRUSH) , ByVal VarPtr(LOG_BRUSH)
                ForeColor = 0
                BackColor = LOG_BRUSH.lbColor
                Exit Sub
            End If

            If ff -> ProcessCtlColor Then
                If ff -> IsForeSysColor Then
                    ForeColor = GetSysColor(ff -> nForeColor)
                Else
                    ForeColor = ff -> nForeColor
                End If

                If ff -> IsBackSysColor Then
                    BackColor = GetSysColor(ff -> nBackColor)
                Else
                    BackColor = ff -> nBackColor
                End If

            Else
                ForeColor = GetSysColor(ff -> nForeColor)
                BackColor = GetSysColor(ff -> nBackColor)
            End If

        End If

    End If
End Sub

Private Function FF_Control_GetTag(ByVal hWndControl As HWND) As String

    Dim pzString As ZString Ptr

    'Get the pointer to the Tag string from the hWnd PROP.
    pzString = GetProp(hWndControl , "FLY_TAGPROPERTY")

    If pzString = 0 Then
        'Null pointer
        Function = ""
    Else
        Function = *pzString
    End If

End Function

Private Function FF_Control_GetTag2(ByVal hWndControl As HWND) As String

    Dim pzString As ZString Ptr

    'Get the pointer to the Tag2 string from the hWnd PROP.
    pzString = GetProp(hWndControl , "FLY_TAGPROPERTY2")

    If pzString = 0 Then
        'Null pointer
        Function = ""
    Else
        Function = *pzString
    End If

End Function

Private Function FF_Control_GetText(ByVal hWndControl As HWND) As String
    Dim nBufferSize As Long
    Dim nBuffer As String

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        ' Get the length of the text
        nBufferSize = GetWindowTextLength(hWndControl)
        If nBufferSize = 0 Then
            Function = "" : Exit Function
        End If

        ' Add an extra character for the Nul terminator
        nBufferSize = nBufferSize + 1

        ' Create the temporary buffer
        nBuffer = Space(nBufferSize)

        ' Retrieve the text
        GetWindowText hWndControl , ByVal StrPtr(nBuffer) , nBufferSize

        ' Remove the Null
        nBuffer = RTrim(nBuffer , chr(0))

        Function = nBuffer

    End If
End Function

Private Sub FF_Control_Redraw(ByVal hWndControl As HWND)

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        ' Signal the Control to be redrawn.
        InvalidateRect hWndControl , ByVal 0 , True
        UpdateWindow hWndControl

    End If
End Sub

Private Sub FF_Control_SetCheck(ByVal hWndControl as HWnd , _
            ByVal nCheckState as Long)

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        ' Set the check state
        If nCheckState Then
            SendMessage hWndControl , BM_SETCHECK , BST_CHECKED , 0
        Else
            SendMessage hWndControl , BM_SETCHECK , BST_UNCHECKED , 0
        End If

    End If

End Sub

Private Sub FF_Control_SetColor(ByVal hWndControl as HWnd , _
            ByVal ForeColor as Long , _
            ByVal BackColor as Long)

    Dim ff_control as FLY_DATA Ptr
    Dim Redraw_Flag as Long

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        ff_control = GetProp(hWndControl , "FLY_PTR")

        If ff_control Then

            ' Determine is we are dealing with a Form or Control
            If ff_control -> IsForm Then

                ' ForeColor has no effect on a Form

                ' Set the Background color
                If BackColor <> - 1 Then
                    If ff_control -> hBackBrush Then
                        DeleteObject ff_control -> hBackBrush
                    End If
                    ff_control -> hBackBrush = CreateSolidBrush(BackColor)
                    ff_control -> nBackColor = BackColor
                    ff_control -> IsBackSysColor = False
                    SetClassLongPtr hWndControl , GCLP_HBRBACKGROUND , Cast(Integer , CreateSolidBrush(BackColor))
                    Redraw_Flag = True
                End If

            Else

                ' Set the Foreground color
                If ForeColor <> - 1 Then
                    ff_control -> nForeColor = ForeColor
                    ff_control -> IsForeSysColor = False
                    Redraw_Flag = True
                End If

                ' Set the Background color
                If BackColor <> - 1 Then
                    If ff_control -> hBackBrush Then
                        DeleteObject ff_control -> hBackBrush
                    End If
                    ff_control -> hBackBrush = CreateSolidBrush(BackColor)
                    ff_control -> nBackColor = BackColor
                    ff_control -> IsBackSysColor = False
                    Redraw_Flag = True
                End If

            End If

            If Redraw_Flag Then
                InvalidateRect hWndControl , ByVal 0 , TRUE
                UpdateWindow hWndControl
            End If

        End If

    End If
End Sub

Private Sub FF_Control_SetTag(ByVal hWnd As HWND , _
            ByRef NewTag As String)

    If IsWindow(hWnd) = 0 Then Exit Sub

    Dim pzString As ZString Ptr

    ' Get the pointer to the Tag string from the hWnd PROP.
    pzString = GetProp(hWnd , "FLY_TAGPROPERTY")

    ' Free any currently allocated memory
    If pzString Then HeapFree GetProcessHeap() , 0 , ByVal pzString

    If Right(NewTag , 1) <> Chr(0) Then NewTag = NewTag & Chr(0)

    pzString = HeapAlloc(GetProcessHeap() , HEAP_ZERO_MEMORY , Len(NewTag) + 1)
    If pzString Then * pzString = NewTag

    SetProp hWnd , "FLY_TAGPROPERTY" , pzString

End Sub


Private Sub FF_Control_SetTag2(ByVal hWnd As HWND , _
            ByRef NewTag As String)

    If IsWindow(hWnd) = 0 Then Exit Sub

    Dim pzString As ZString Ptr

    ' Get the pointer to the Tag string from the hWnd PROP.
    pzString = GetProp(hWnd , "FLY_TAGPROPERTY2")

    ' Free any currently allocated memory
    If pzString Then HeapFree GetProcessHeap() , 0 , ByVal pzString

    If Right(NewTag , 1) <> Chr(0) Then NewTag = NewTag & Chr(0)

    pzString = HeapAlloc(GetProcessHeap() , HEAP_ZERO_MEMORY , Len(NewTag) + 1)
    If pzString Then * pzString = NewTag

    SetProp hWnd , "FLY_TAGPROPERTY2" , pzString

End Sub


Private Sub FF_Control_SetText(ByVal hWndControl As HWND , _
            ByRef TheText As String)

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        ' Set the control's text
        SetWindowText hWndControl , TheText

    End If
End Sub


Private Function FF_Control_ShowState(ByVal hWndControl As HWND , _
            ByVal nShowState As Integer _
            ) As Integer

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        ' Set the show state
        Function = ShowWindow(hWndControl , nShowState)

    End If

End Function

'//
'// Extract the file name from a path
'//
Private Function FF_FileName(ByRef Src As String) As String

    Dim x As Long

    x = InStrrev(Src , Any ":/\")

    If x Then
        Function = Mid(Src , x + 1)
    Else
        Function = Src
    End If

End Function

'//
'// Extract the path from a file name
'//
Private Function FF_FilePath(ByRef Src As String) As String

    Dim x As Long

    x = InStrrev(Src , Any ":\/")

    If x Then
        Function = Left(Src , x)
    End If

End Function


Private Sub FF_CloseForm(ByVal hwndForm As HWND , _
            ByVal ReturnValue As Integer = 0)

    If IsWindow(hWndForm) = False Then Exit Sub

    Dim hWndParent As HWND

    Dim ff As FLY_DATA Ptr
    ff = GetProp(hwndForm , "FLY_PTR")

    If ff Then
        If ff -> IsModal Then
            ' Reset the focus back to the parent of the modal form.
            ' Enable Mouse and keyboard input for the Parent Form
            hWndParent = Cast(HWND , GetWindowLongPtr(hWndForm , GWLP_HWNDPARENT))
            If IsWindow(hWndParent) Then
                EnableWindow hWndParent , True
                SetActiveWindow hWndParent
            End If
        End If
    End If

    'Destroy the window. This will delete any font objects and release
    'the memory held by the type structure.
    DestroyWindow hWndForm

    'Set the value that will be returned to the calling program.
    App.ReturnValue = ReturnValue
End Sub


' ========================================================================================
' Returns the point size of a font given its logical height
' Based on code from Jose Roca
' ========================================================================================
Private Function FF_AfxGetFontPointSize(ByVal nHeight As Long) As Long
    Dim hdc As HDC
    hdc = CreateDC( "DISPLAY" , ByVal Null , ByVal Null , ByVal Null)
    If hdc = Null Then Exit Function
    Dim cyPixelsPerInch As Long
    cyPixelsPerInch = GetDeviceCaps(hdc , LOGPIXELSY)
    DeleteDC hdc
    Dim nPointSize As Long
    nPointSize = MulDiv(nHeight , 72 , cyPixelsPerInch)
    If nPointSize < 0 Then nPointSize = - nPointSize
    Function = nPointSize
End Function


Private Function FF_GetFontInfo(ByRef sCurValue As String , _
            ByRef sFontName As String , _
            ByRef nPointSize As Long , _
            ByRef nWeight As Long , _
            ByRef nItalic As Long , _
            ByRef nUnderline As Long , _
            ByRef nStrikeOut As Long , _
            ByRef nFontStyle As Long _
            ) As Long

    ' FireFly handles two types of font strings. The first is the traditional
    ' logfont string and the second is the simplified PB version. FireFly is moving
    ' towards the simplified version but needs to handle the logfont version
    ' for backwards compatibility.

    ' Count the number of commas in the incoming string
    Dim nCount As Integer
    Dim i As Integer

    For i = 0 To Len(sCurValue) - 1
        If sCurValue[i] = 44 Then nCount = nCount + 1
    Next

    If nCount > 10 Then
        ' This must be the old style logfont structure
        ' "Tahoma,-11,0,0,0,400,0,0,0,0,3,2,1,34" ' 400 = normal, 700 = bold
        sFontName = FF_Parse(sCurValue , "," , 1)
        nPointSize = FF_AfxGetFontPointSize(ValInt(FF_Parse(sCurValue , "," , 2)))
        nWeight = ValInt(FF_Parse(sCurValue , "," , 6))
        nItalic = ValInt(FF_Parse(sCurValue , "," , 7))
        nUnderline = ValInt(FF_Parse(sCurValue , "," , 8))
        nStrikeOut = ValInt(FF_Parse(sCurValue , "," , 9))
        If nWeight = FW_BOLD Then nFontStyle = nFontStyle + 1 ' normal/bold
        If nItalic Then nFontStyle = nFontStyle + 2 ' italic
        If nUnderline Then nFontStyle = nFontStyle + 4 ' underline
        If nStrikeOut Then nFontStyle = nFontStyle + 8 ' strikeout
    Else
        ' This is the new style (3 parts)
        sFontName = FF_Parse(sCurValue , "," , 1)
        nPointSize = ValInt(FF_Parse(sCurValue , "," , 2))
        nFontStyle = ValInt(FF_Parse(sCurValue , "," , 3))
        nWeight = FW_NORMAL
        If (nFontStyle And 1) Then nWeight = FW_BOLD
        If (nFontStyle And 2) Then nItalic = TRUE
        If (nFontStyle And 4) Then nUnderline = TRUE
        If (nFontStyle And 8) Then nStrikeOut = TRUE
    End If

    Function = 0

End Function


Function FF_EnumCharSet( _
            ByRef elf As ENUMLOGFONT , _
            ByRef ntm As NEWTEXTMETRIC , _
            ByVal FontType As Long , _
            ByVal CharSet As Long _
            ) As Long

    CharSet = elf.elfLogFont.lfCharSet
    Function = TRUE
End Function


Private Function FF_MakeFontEX(Byref sFont As String , _
            ByVal PointSize As Long , _
            ByVal fBold As Long , _
            ByVal fItalic As Long , _
            ByVal fUnderline As Long , _
            ByVal StrikeThru As Long _
            ) As HFONT

    Dim tlf As LOGFONT
    Dim hDC As HDC
    Dim CharSet As Integer
    Dim m_DPI As Integer

    ' Create a high dpi aware font
    If Len(sFont) = 0 Then Exit Function

    hDC = GetDC(0)

    EnumFontFamilies hDC , ByVal StrPtr(sFont) , Cast(FONTENUMPROC , @FF_EnumCharSet) , ByVal Cast(LPARAM , VarPtr(CharSet))

    m_DPI = GetDeviceCaps(hDC , LOGPIXELSX)
    PointSize = (PointSize * m_DPI) \ GetDeviceCaps(hDC , LOGPIXELSY)

    tlf.lfHeight = - MulDiv(PointSize , GetDeviceCaps(hDC , LOGPIXELSY) , 72) ' logical font height
    tlf.lfWidth = 0                              ' average character width
    tlf.lfEscapement = 0                         ' escapement
    tlf.lfOrientation = 0                        ' orientation angles
    tlf.lfWeight = fBold                         ' font weight
    tlf.lfItalic = fItalic                       ' italic(TRUE/FALSE)
    tlf.lfUnderline = fUnderline                 ' underline(TRUE/FALSE)
    tlf.lfStrikeOut = StrikeThru                 ' strikeout(TRUE/FALSE)
    tlf.lfCharSet = Charset                      ' character set
    tlf.lfOutPrecision = OUT_TT_PRECIS           ' output precision
    tlf.lfClipPrecision = CLIP_DEFAULT_PRECIS    ' clipping precision
    tlf.lfQuality = DEFAULT_QUALITY              ' output quality
    tlf.lfPitchAndFamily = FF_DONTCARE           ' pitch and family
    tlf.lfFaceName = sFont                       ' typeface name

    ReleaseDC 0 , hDC

    Function = CreateFontIndirect(@tlf)

End Function



Private Function FF_MakeFontEx_Internal(byref sFont As String) As HFONT
    Dim hFont As HFONT
    Dim sFontName As String
    Dim nPointSize As Long
    Dim nWeight As Long
    Dim nItalic As Long
    Dim nUnderline As Long
    Dim nStrikeOut As Long
    Dim nFontStyle As Long

    FF_GetFontInfo sFont , sFontName , nPointSize , nWeight , nItalic , nUnderline , nStrikeOut , nFontStyle
    hFont = FF_MakeFontEx(sFontName , nPointSize , nWeight , nItalic , nUnderline , nStrikeOut)

    ' Add this font to the global shared font array
    Dim nSlot As Long = - 1
    For x As Long = LBound(gFLY_FontHandles) To Ubound(gFLY_FontHandles)
        If gFLY_FontHandles(x) = 0 Then
            nSlot = x : Exit For
        End If
    Next
    If nSlot = - 1 Then                          ' could not find an empty slot
        nSlot = Ubound(gFLY_FontHandles) + 1
        ReDim Preserve gFLY_FontHandles(nSlot) As HFONT
    End If
    gFLY_FontHandles(nSlot) = hFont

    Function = hFont
End Function



' Help function for FF_OpenFileDialog that will center the dialog on the screen.
Private Function FF_CenterOpenFileDialog(ByVal HWnd as HWnd , _
            ByVal wMsg as UInteger , _
            ByVal wParam as WPARAM , _
            ByVal lParam as LPARAM _
            ) as Long

    Dim pNMHDR as NMHDR Ptr
    Dim rc1 as Rect
    Dim rc2 as Rect

    If wMsg = WM_NOTIFY Then
        pNMHDR = Cast(Any Ptr , lParam)

        If pNMHDR -> Code = CDN_INITDONE Then
            GetWindowRect GetDesktopWindow , VarPtr(rc1)
            GetWindowRect GetParent(HWnd) , VarPtr(rc2)
            SetWindowPos GetParent(HWnd) , HWND_TOPMOST ,(rc1.Left + rc1.Right - rc2.Right + rc2.Left) / 2 , _
                    (rc1.Top + rc1.Bottom - rc2.Bottom + rc2.Top) / 2 , 0 , 0 , SWP_NOSIZE Or SWP_NOACTIVATE

            Function = True : Exit Function
        End If

    End If
End Function

Private Function FF_OpenFileDialog(ByVal HWnd as HWnd , _
            ByRef sCaption as String , _
            ByRef FileSpec as String , _
            ByRef InitialDir as String , _
            ByRef Filter As String , _
            ByRef DefExtension As String , _
            ByVal Flags As UInteger , _
            ByVal CenterFlag As Integer _
            ) As Integer

    Dim sFile As String
    Dim Ofn As OPENFILENAME                      'OFNA
    Dim zFileTitle As ZString * MAX_PATH
    Dim zInitialDir As ZString * MAX_PATH
    Dim zTitle As ZString * MAX_PATH
    Dim zDefExt As ZString * 10
    Dim hHook As Integer

    Filter = FF_Replace(Filter , "|" , Chr(0))

    If Len(InitialDir) = 0 Then InitialDir = Curdir

    Filter = Filter & Chr(0)
    zInitialDir = InitialDir & Chr(0)

    sFile = String(16383 , 0)                    '<- PLENTY OF ROOM FOR MULTIPLE FILES
    Mid(sFile , 1) = FileSpec

    zDefExt = DefExtension & Chr(0)
    zTitle = sCaption & Chr(0)

    ofn.lStructSize = SizeOf(OPENFILENAME)
    ofn.hWndOwner = HWnd
    ofn.lpstrFilter = StrPtr(Filter)
    ofn.nFilterIndex = 1
    ofn.lpstrFile = StrPtr(sFile)
    ofn.nMaxFile = Len(sFile)
    ofn.lpstrFileTitle = VarPtr(zFileTitle)
    ofn.nMaxFileTitle = Sizeof(zFileTitle)
    ofn.lpstrInitialDir = Varptr(zInitialDir)
    ' ofn.FlagsEx = 0
    If Len(zTitle) Then
        ofn.lpstrTitle = Varptr(zTitle)
    End If

    'If needed, hook the Common dialog so it centers on the screen
    If CenterFlag Then
        If Flags = 0 Then
            Flags = OFN_EXPLORER Or OFN_ENABLESIZING
        End If
        Flags = Flags Or OFN_ENABLEHOOK
        ofn.lpfnHook = Cast(LPOFNHOOKPROC , @FF_CenterOpenFileDialog)
    End If

    ofn.Flags = Flags
    ofn.lpstrDefExt = Varptr(zDefExt)

    Function = GetOpenFileName(ByVal Varptr(ofn))

    Filespec = RTrim(sFile , chr(0))             ' return the filename(s)
End Function



Private Function FF_ListView_DeleteAllItems(ByVal hWndControl As HWND) As Long

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        ' Remove all items from the ListView
        Function = SendMessage(hWndControl , LVM_DELETEALLITEMS , 0 , 0)
    End If

End Function



Private Function FF_ListView_DeleteItem(ByVal hWndControl as HWnd , _
            ByVal iPosition as Long _
            ) as Long

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        ' Remove all items from the ListView
        Function = ListView_DeleteItem(hWndControl , iPosition)
    End If
End Function



Private Function FF_ListView_GetColumnAlignment(ByVal hWndControl as HWnd , _
            ByVal iPosition as Long _
            ) as Long

    Dim tlvc as LV_COLUMN

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        tlvc.mask = LVCF_FMT
        If SendMessage(hWndControl , LVM_GETCOLUMN , iPosition , Cast(LPARAM , VarPtr(tlvc))) Then
            If (tlvc.fmt And LVCFMT_RIGHT) = LVCFMT_RIGHT Then
                Function = LVCFMT_RIGHT : Exit Function
            End If
            If (tlvc.fmt And LVCFMT_CENTER) = LVCFMT_CENTER Then
                Function = LVCFMT_CENTER : Exit Function
            End If
            If (tlvc.fmt And LVCFMT_LEFT) = LVCFMT_LEFT Then
                Function = LVCFMT_LEFT : Exit Function
            End If
        End If

    End If
End Function



Private Function FF_ListView_GetItemCount(ByVal hWndControl As HWND) As Long

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        Function = SendMessage(hWndControl , LVM_GETITEMCOUNT , 0 , 0)

    End If
End Function



Private Function FF_ListView_GetItemImage(ByVal hWndControl as HWnd , _
            ByVal iRow as Long , _
            ByVal iColumn as Long _
            ) as Long

    Dim tlv_item as LV_ITEM

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        tlv_item.mask = LVIF_IMAGE
        tlv_item.iItem = iRow
        tlv_item.iSubItem = iColumn

        If SendMessage(hWndControl , LVM_GETITEM , 0 , Cast(LPARAM , VarPtr(tlv_item))) Then
            Function = Cast(Integer , tlv_item.iImage)
        End If

    End If
End Function



Private Function FF_ListView_GetItemlParam(ByVal hWndControl as HWnd , _
            ByVal iRow as Long , _
            ByVal iColumn as Long) as Long

    Dim tlv_item as LV_ITEM

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        tlv_item.mask = LVIF_PARAM
        tlv_item.iItem = iRow
        tlv_item.iSubItem = iColumn

        If SendMessage(hWndControl , LVM_GETITEM , 0 , Cast(LPARAM , VarPtr(tlv_item))) Then
            Function = tlv_item.lParam
        End If

    End If
End Function



Private Function FF_ListView_GetItemText(ByVal hWndControl as HWnd , _
            ByVal iRow as Long , _
            ByVal iColumn as Long _
            ) as String

    Dim tlv_item as LV_ITEM
    Dim zText as ZString * MAX_PATH

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        tlv_item.mask = LVIF_TEXT
        tlv_item.iItem = iRow
        tlv_item.iSubItem = iColumn
        tlv_item.pszText = VarPtr(zText)
        tlv_item.cchTextMax = SizeOf(zText)

        If SendMessage(hWndControl , LVM_GETITEM , 0 , Cast(LPARAM , VarPtr(tlv_item))) Then
            Function = zText
        End If

    End If
End Function



Private Function FF_ListView_GetSelectedItem(ByVal hWndControl As HWND) As Long

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        Function = SendMessage(hWndControl , LVM_GETSELECTIONMARK , 0 , 0)
    End If
End Function



Private Function FF_ListView_InsertColumn(ByVal hWndControl as HWnd , _
            ByVal iPosition as Long , _
            ByRef TheText as String , _
            ByVal nAlignment as Long = LVCFMT_LEFT , _
            ByVal nWidth as Long = 100 _
            ) as Integer

    Dim tlvc as LV_COLUMN

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        tlvc.mask = LVCF_FMT Or LVCF_WIDTH Or LVCF_TEXT Or LVCF_SUBITEM
        tlvc.fmt = nAlignment
        tlvc.cx = nWidth
        tlvc.pszText = StrPtr(TheText)
        tlvc.iSubItem = 0
        Function = SendMessage(hWndControl , LVM_INSERTCOLUMN , iPosition , Cast(LPARAM , VarPtr(tlvc)))

    End If
End Function



Private Function FF_ListView_InsertItem(ByVal hWndControl as HWnd , _
            ByVal iRow as Long , _
            ByVal iColumn as Long , _
            ByRef TheText as String , _
            ByVal lParam as Long = 0 , _
            ByVal iImage as Long = 0 _
            ) as Integer

    Dim tlv_item as LV_ITEM

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        tlv_item.iItem = iRow
        tlv_item.iSubItem = iColumn
        tlv_item.pszText = StrPtr(TheText)
        tlv_item.iImage = iImage
        tlv_item.lParam = lParam

        If iColumn = 0 Then
            tlv_item.mask = LVIF_TEXT Or LVIF_PARAM Or LVIF_IMAGE
            Function = SendMessage(hWndControl , LVM_INSERTITEM , 0 , Cast(LPARAM , VarPtr(tlv_item)))
        Else
            tlv_item.mask = LVIF_TEXT Or LVIF_IMAGE
            Function = SendMessage(hWndControl , LVM_SETITEM , 0 , Cast(LPARAM , VarPtr(tlv_item)))
        End If
    End If
End Function



Private Function FF_ListView_SetColumnAlignment(ByVal hWndControl as HWnd , _
            ByVal iPosition as Long , _
            ByVal nAlignment as Long _
            ) as Integer

    Dim tlvc as LV_COLUMN

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then

        tlvc.mask = LVCF_FMT
        tlvc.fmt = nAlignment
        Function = SendMessage(hWndControl , LVM_SETCOLUMN , iPosition , Cast(LPARAM , VarPtr(tlvc)))

    End If
End Function



Private Function FF_ListView_SetItemImage(ByVal hWndControl as HWnd , _
            ByVal iRow as Long , _
            ByVal iColumn as Long , _
            ByVal iImage as Long _
            ) as Integer

    Dim tlv_item as LV_ITEM

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        tlv_item.mask = LVIF_IMAGE
        tlv_item.iItem = iRow
        tlv_item.iSubItem = iColumn
        tlv_item.iImage = iImage

        Function = SendMessage(hWndControl , LVM_SETITEM , 0 , Cast(LPARAM , VarPtr(tlv_item)))

    End If
End Function



Private Function FF_ListView_SetItemlParam(ByVal hWndControl as HWnd , _
            ByVal iRow as Long , _
            ByVal iColumn as Long , _
            ByVal lParam as Long _
            ) as Integer

    Dim tlv_item as LV_ITEM

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        tlv_item.mask = LVIF_PARAM
        tlv_item.iItem = iRow
        tlv_item.iSubItem = iColumn
        tlv_item.lParam = lParam

        Function = SendMessage(hWndControl , LVM_SETITEM , 0 , Cast(LPARAM , VarPtr(tlv_item)))

    End If
End Function



Private Function FF_ListView_SetItemText(ByVal hWndControl as HWnd , _
            ByVal iRow as Long , _
            ByVal iColumn as Long , _
            ByRef TheText as String _
            ) as Long

    Dim tlv_item as LV_ITEM

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        tlv_item.mask = LVIF_TEXT
        tlv_item.iItem = iRow
        tlv_item.iSubItem = iColumn
        tlv_item.pszText = StrPtr(TheText)
        tlv_item.cchTextMax = Len(TheText)

        Function = SendMessage(hWndControl , LVM_SETITEM , 0 , Cast(LPARAM , VarPtr(tlv_item)))

    End If
End Function



Private Function FF_ListView_SetSelectedItem(ByVal hWndControl as HWnd , _
            ByVal nIndex as Long _
            ) as Long

    ' Do a check to ensure that this is actually a window handle
    If IsWindow(hWndControl) Then
        Function = SendMessage(hWndControl , LVM_SETSELECTIONMARK , 0 , nIndex)

        'ensure that the item is set visually as well
        Dim tItem as LVITEM
        tItem.mask = LVIF_STATE
        tItem.iItem = nIndex
        tItem.iSubItem = 0
        tItem.State = LVIS_FOCUSED Or LVIS_SELECTED
        tItem.statemask = LVIS_FOCUSED Or LVIS_SELECTED
        SendMessage hWndControl , LVM_SETITEMSTATE , nIndex , Cast(LPARAM , VarPtr(tItem))
    End If
End Function



''
'' FF_PARSE
'' Return a delimited field from a string expression.
''
'' Delimiter contains a string of one or more characters that must be fully matched to be successful.
'' If nPosition evaluates to zero or is outside of the actual field count, an empty string is returned.
'' If nPosition is negative then fields are searched from the right to left of the MainString.
'' Delimiters are case-sensitive,
''
Private Function FF_Parse(ByRef sMainString as String , _
            ByRef sDelimiter as String , _
            ByVal nPosition as Integer _
            ) as String
    ' The parse must match the entire deliminter string
    Function = FF_Parse_Internal(sMainString , sDelimiter , nPosition , False , Len(sDelimiter))
End Function





''
'' FF_PARSE_INTERNAL
'' Used by both FF_Parse and FF_ParseAny (internal function)
''
Private Function FF_Parse_Internal(ByRef sMainString as String , _
            ByRef sDelimiter as String , _
            ByRef nPosition as Integer , _
            ByRef nIsAny as Integer , _
            ByRef nLenDelimiter as Integer _
            ) as String

    ' Returns the nPosition-th substring in a string sMainString with separations sDelimiter (one or more charcters),
    ' beginning with nPosition = 1

    Dim as Integer i , j , count
    Dim s as String
    Dim fReverse as Integer = IIf(nPosition < 0 , True , False)

    nPosition = Abs(nPosition)
    count = 0
    i = 1
    s = sMainString

    If fReverse Then
        ' Reverse search
        ' Get the start of the token (j) by searching in reverse
        If nIsAny Then
            i = InStrRev(sMainString , Any sDelimiter)
        Else
            i = InStrRev(sMainString , sDelimiter)
        End If
        Do While i > 0                           ' if not found loop will be skipped
            j = i + nLenDelimiter
            count += 1
            i = i - nLenDelimiter
            If count = nPosition Then Exit Do
            If nIsAny Then
                i = InStrRev(sMainString , Any sDelimiter , i)
            Else
                i = InStrRev(sMainString , sDelimiter , i)
            End If
        Loop
        If i = 0 Then j = 1

        ' Now continue forward to get the end of the token
        If nIsAny Then
            i = InStr(j , sMainString , Any sDelimiter)
        Else
            i = InStr(j , sMainString , sDelimiter)
        End If
        If (i > 0) Or (count = nPosition) Then
            If i = 0 Then
                s = Mid(sMainString , j)
            Else
                s = Mid(sMainString , j , i - j)
            End If
        End If

    Else

        ' Forward search
        Do
            j = i
            If nIsAny Then
                i = InStr(i , sMainString , Any sDelimiter)
            Else
                i = InStr(i , sMainString , sDelimiter)
            End If
            If i > 0 Then count += 1 : i += nLenDelimiter
        Loop Until(i = 0) Or (count = nPosition)

        If (i > 0) Or (count = nPosition - 1) Then
            If i = 0 Then
                s = Mid(sMainString , j)
            Else
                s = Mid(sMainString , j , i - nLenDelimiter - j)
            End If
        End If
    End If

    Return s
End Function



''
'' FF_REPLACE
'' Within a specified string, replace all occurrences of one string with another string.
''
'' Replaces all occurrences of MatchPattern in MainString with ReplaceWith.
'' The replacement can cause MainString to grow or condense in size.
'' This function is case-sensitive.
'' When a match is found, the scan for the next match begins at the position
'' immediately following the prior match.
''
Private Function FF_Replace(ByRef sMainString As String , _
            ByRef sMatchPattern As String , _
            ByRef sReplaceWith As String _
            ) As String

    Dim i As Integer
    Dim s As String

    s = sMainString
    i = 1
    Do
        i = Instr(i , s , sMatchPattern)
        If i > 0 Then
            s = Left(s , i - 1) & sReplaceWith & Mid(s , i + Len(sMatchPattern))
            i += Len(sReplaceWith)
        End If
    Loop Until i = 0

    Return s
End Function


''
'' FF_REPLACEANY
'' Within a specified string, replace all occurrences of any of the individual characters
'' specified in the MatchPattern string.
''
'' This function is case-sensitive.
'' sReplaceWidth must be a single character. This function does not replace words therefore
'' MainString will be the same size - it will not shrink or grow.
''
Private Function FF_ReplaceAny(ByRef sMainString As String , _
            ByRef sMatchPattern As String , _
            ByRef sReplaceWith As String _
            ) As String

    Dim nLenMain As Integer = Len(sMainString)
    Dim nLenMatch As Integer = Len(sMatchPattern)
    Dim nLenReplace As Integer = Len(sReplaceWith)

    Dim s As String
    Dim y As Integer
    Dim i As Integer

    ' Note: sReplaceWith must be one character in size because this function
    ' replaces individual characters rather than words.
    If nLenReplace <> 1 Then Return sMainString
    If nLenMain = 0 Then Return sMainString
    If nLenMatch = 0 Then Return sMainString

    s = sMainString                              ' make a default return copy of the string

    ' Get each character in the sMatchPattern string and look for it in sMainString
    ' Using string pointer indexing for speed.
    For y = 0 To nLenMatch - 1
        For i = 0 To nLenMain - 1
            If sMatchPattern[y] = sMainString[i] Then
                s[i] = sReplaceWith[0]
            End If
        Next
    Next

    Function = s
End Function



Private Function FORM1_Show(ByVal hWndParent As HWND , _
            ByVal ShowModalFlag As Long , _
            ByVal UserData As long = 0 _
            ) As HWND

    Dim szClassName As zString * MAX_PATH
    Dim wce As WndClassEx

    Dim FLY_nLeft As Long
    Dim FLY_nTop As Long
    Dim FLY_nWidth As Long
    Dim FLY_nHeight As Long

    Dim hWndForm As HWND
    Dim IsMDIForm as Long

    Static IsInitialized As Long

    'Determine if the Class already exists. If it does not, then create the class.
    szClassName = "FORM_ENCRYPT_FORM1_CLASS"
    wce.cbSize = SizeOf(wce)
    IsInitialized = GetClassInfoEx(App.hInstance , szClassName , varptr(wce))

    If IsInitialized = 0 Then
        wce.cbSize = SizeOf(wce)
        wce.STYLE = CS_VREDRAW Or CS_HREDRAW Or CS_DBLCLKS
        wce.lpfnWndProc = Cast(WNDPROC , @FORM1_FORMPROCEDURE)
        wce.cbClsExtra = 0
        wce.cbWndExtra = 0
        wce.hInstance = App.hInstance
        wce.hIcon = LoadImage(App.hInstance , "IMAGE_APPLI" , IMAGE_ICON , 32 , 32 , LR_SHARED)
        wce.hCursor = LoadCursor(0 , ByVal IDC_ARROW)
        wce.hbrBackground = Cast(HBRUSH , COLOR_BTNFACE + 1)
        wce.lpszMenuName = 0
        wce.lpszClassName = VarPtr(szClassName)
        wce.hIconSm = LoadImage(App.hInstance , "IMAGE_APPLI" , IMAGE_ICON , 16 , 16 , LR_SHARED)

        If RegisterClassEx(varptr(wce)) Then IsInitialized = TRUE
    End If

    ' // Set the flag if this is an MDI form we are creating
    IsMDIForm = FALSE

    ' // Save the optional UserData to be checked in the Form Procedure CREATE message
    App.ReturnValue = UserData

    ' Set the size/positioning of the window about to be created
    FLY_nLeft = afxScaleX(0) : FLY_nTop = afxScaleY(0)
    FLY_nWidth = afxScaleX(1194) : FLY_nHeight = afxScaleY(519)

    ' Form is to be centered, therefore make the necessary adjustment
    FLY_nLeft = (GetSystemMetrics(SM_CXSCREEN) - FLY_nWidth) \ 2 - 150
    FLY_nTop = (GetSystemMetrics(SM_CYSCREEN) - FLY_nHeight) \ 2 - 100

    ' Create a window using the registered class
    hWndForm = CreateWindowEx(WS_EX_WINDOWEDGE Or WS_EX_CONTROLPARENT _
            Or WS_EX_LEFT Or WS_EX_LTRREADING Or WS_EX_RIGHTSCROLLBAR _
             , _
            szClassName , _                              ' window class name
            __NAME_APPLI_VERSION__ , _                   ' window caption
            WS_POPUP Or WS_THICKFRAME Or WS_CAPTION Or WS_SYSMENU _
            Or WS_MINIMIZEBOX  /' Or WS_MAXIMIZEBOX '/  Or WS_CLIPSIBLINGS _
            Or WS_CLIPCHILDREN , _
            FLY_nLeft , FLY_nTop , FLY_nWidth , FLY_nHeight , _
            hwndParent , _                               ' parent window handle
            Cast(HMENU , Cast(LONG_PTR , Null)) , _      ' window menu handle/child identifier
            App.hInstance , _                            ' program instance handle
            ByVal Cast(LPVOID , Cast(LONG_PTR , UserData)))

    If IsWindow(hWndForm) = 0 Then
        Function = 0 : Exit Function
    End If

    Function = FLY_DoMessagePump(ShowModalFlag , hWndForm , hWndParent , SW_SHOWNORMAL , IsMDIForm)
End Function



'------------------------------------------------------------------------------
' Create all child controls for FORM1
'------------------------------------------------------------------------------
Private Sub FORM1_CreateControls(ByVal hWndForm As HWND)

    ' All of the child controls for the FORM1 form are
    ' created in this subroutine. This subroutine is called
    ' from the WM_CREATE message of the form.

    Dim FLY_zTempString As zString * MAX_PATH

    Dim FLY_hPicture As HANDLE
    Dim hWndControl As HWND
    Dim FLY_ScrollInfo As ScrollInfo
    Dim FLY_TBstring As String
    Dim FLY_Notify As NMHDR
    Dim FLY_ImageListNormal As HANDLE , FLY_ImageListDisabled As HANDLE , FLY_ImageListHot As HANDLE

    Dim FLY_hStatusBar As HWND , FLY_hRebar As HWND , FLY_hToolBar As HWND
    Dim FLY_tempLong As Long , FLY_hFont As HFONT , FLY_hIcon As HICON
    Dim FLY_hMemDC As HDC , FLY_ImageIndex As Long
    Dim FLY_ClientOffset As Long

    Dim FLY_RECT As Rect
    Dim FLY_TabRect As Rect

    Dim FLY_TCITEM As TC_ITEM
    Dim uVersion As OSVERSIONINFO
    Dim DateRange(1) As SYSTEMTIME


    Dim ff As FLY_DATA Ptr
    Dim FLY_child As FLY_DATA Ptr
    Dim FLY_parent As FLY_DATA Ptr

    FLY_parent = GetProp(hWndForm , "FLY_PTR")

	'------------------------------------------------------------------------------
    ' Create COMMAND7 [CommandButton] control.
    '------------------------------------------------------------------------------
     hWndControl = CreateWindowEx(WS_EX_LEFT Or WS_EX_LTRREADING , _
            "Button" , _
            "Clear Status" , _
            WS_CHILD Or WS_VISIBLE Or WS_TABSTOP Or BS_TEXT _
            Or BS_PUSHBUTTON Or BS_NOTIFY Or BS_CENTER Or BS_VCENTER _
             , _
            afxScaleX(1072) , afxScaleY(FLY_ClientOffset + 225) , _
            afxScaleX(91) , afxScaleY(37) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_COMMAND7)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , FALSE , _
            FALSE , FALSE , 0 , _
            0 , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = "Clear All listed Status "
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_COMMAND7 = hWndControl


    '------------------------------------------------------------------------------
    ' Create COMMAND6 [CommandButton] control.
    '------------------------------------------------------------------------------
    hWndControl = CreateWindowEx(WS_EX_LEFT Or WS_EX_LTRREADING , _
            "Button" , _
            "X All Forced" , _
            WS_CHILD Or WS_TABSTOP Or BS_TEXT Or BS_PUSHBUTTON _
            Or BS_NOTIFY Or BS_CENTER Or BS_VCENTER , _
            afxScaleX(1072) , afxScaleY(FLY_ClientOffset + 300) , _
            afxScaleX(92) , afxScaleY(37) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_COMMAND6)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , FALSE , _
            FALSE , FALSE , 0 , _
            0 , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = "Extended: Force convert all existing Pdf"
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_COMMAND6 = hWndControl

    '------------------------------------------------------------------------------
    ' Create LABEL1 [Label] control.
    '------------------------------------------------------------------------------
    hWndControl = CreateWindowEx(WS_EX_LEFT Or WS_EX_LTRREADING , _
            "Static" , _
            "" , _
            WS_CHILD Or WS_VISIBLE Or WS_CLIPSIBLINGS Or WS_CLIPCHILDREN _
            Or SS_LEFT Or SS_NOTIFY , _
            afxScaleX(492) , afxScaleY(FLY_ClientOffset + 460) , _
            afxScaleX(508) , afxScaleY(24) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_LABEL1)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , TRUE , _
            TRUE , TRUE , COLOR_WINDOWTEXT , _
            COLOR_BTNFACE , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = ""
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_LABEL1 = hWndControl

    '------------------------------------------------------------------------------
    ' Create COMMAND5 [CommandButton] control.
    '------------------------------------------------------------------------------
    hWndControl = CreateWindowEx(WS_EX_LEFT Or WS_EX_LTRREADING , _
            "Button" , _
            "Force Convert" , _
            WS_CHILD Or WS_VISIBLE Or WS_TABSTOP Or BS_TEXT _
            Or BS_PUSHBUTTON Or BS_NOTIFY Or BS_CENTER Or BS_VCENTER _
             , _
            afxScaleX(1072) , afxScaleY(FLY_ClientOffset + 350) , _
            afxScaleX(91) , afxScaleY(37) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_COMMAND5)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , FALSE , _
            FALSE , FALSE , 0 , _
            0 , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = "Warning : Will replace an already existing Pdf file!"
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_COMMAND5 = hWndControl

    '------------------------------------------------------------------------------
    ' Create LISTVIEW1 [ListView] control.
    '------------------------------------------------------------------------------
    hWndControl = CreateWindowEx(WS_EX_CLIENTEDGE Or WS_EX_LEFT Or WS_EX_RIGHTSCROLLBAR _
             , _
            "SysListView32" , _
            "" , _
            WS_CHILD Or WS_VISIBLE Or WS_TABSTOP Or LVS_REPORT _
            Or LVS_SINGLESEL Or LVS_SHOWSELALWAYS , _
            afxScaleX(24) , afxScaleY(FLY_ClientOffset + 16) , _
            afxScaleX(1039) , afxScaleY(376) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_LISTVIEW1)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , FALSE , _
            FALSE , TRUE , 16711680 , _
            COLOR_WINDOW , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = ""
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_LISTVIEW1 = hWndControl

    ListView_SetTextColor(hWndControl , 16711680)
    ListView_SetBkColor(hWndControl , 16777215)
    ListView_SetExtendedListViewStyle(hWndControl ,(ListView_GetExtendedListViewStyle(hWndControl) Or LVS_EX_FULLROWSELECT))
    ListView_SetExtendedListViewStyle(hWndControl ,(ListView_GetExtendedListViewStyle(hWndControl) Or LVS_EX_GRIDLINES))
    ListView_SetExtendedListViewStyle(hWndControl ,(ListView_GetExtendedListViewStyle(hWndControl) Or LVS_EX_BORDERSELECT))
    ListView_SetExtendedListViewStyle(hWndControl ,(ListView_GetExtendedListViewStyle(hWndControl) Or LVS_EX_TWOCLICKACTIVATE))

    '------------------------------------------------------------------------------
    ' Create COMMAND3 [CommandButton] control.
    '------------------------------------------------------------------------------
    hWndControl = CreateWindowEx(WS_EX_LEFT Or WS_EX_LTRREADING , _
            "Button" , _
            "Clear All" , _
            WS_CHILD Or WS_VISIBLE Or WS_TABSTOP Or BS_TEXT _
            Or BS_PUSHBUTTON Or BS_NOTIFY Or BS_CENTER Or BS_VCENTER _
             , _
            afxScaleX(1072) , afxScaleY(FLY_ClientOffset + 96) , _
            afxScaleX(92) , afxScaleY(34) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_COMMAND3)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , FALSE , _
            FALSE , FALSE , 0 , _
            0 , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = "Clear the list, reset it."
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_COMMAND3 = hWndControl

    '------------------------------------------------------------------------------
    ' Create COMMAND4 [CommandButton] control.
    '------------------------------------------------------------------------------
    hWndControl = CreateWindowEx(WS_EX_LEFT Or WS_EX_LTRREADING , _
            "Button" , _
            "Convert All" , _
            WS_CHILD Or WS_VISIBLE Or WS_TABSTOP Or BS_TEXT _
            Or BS_PUSHBUTTON Or BS_NOTIFY Or BS_CENTER Or BS_VCENTER _
             , _
            afxScaleX(620) , afxScaleY(FLY_ClientOffset + 416) , _
            afxScaleX(140) , afxScaleY(38) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_COMMAND4)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , FALSE , _
            FALSE , FALSE , 0 , _
            0 , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = "Will try to convert all listed files to Pdf!"
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_COMMAND4 = hWndControl

    '------------------------------------------------------------------------------
    ' Create COMMAND2 [CommandButton] control.
    '------------------------------------------------------------------------------
    hWndControl = CreateWindowEx(WS_EX_LEFT Or WS_EX_LTRREADING , _
            "Button" , _
            "Del Selected" , _
            WS_CHILD Or WS_VISIBLE Or WS_TABSTOP Or BS_TEXT _
            Or BS_PUSHBUTTON Or BS_NOTIFY Or BS_CENTER Or BS_VCENTER _
             , _
            afxScaleX(1072) , afxScaleY(FLY_ClientOffset + 24) , _
            afxScaleX(92) , afxScaleY(35) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_COMMAND2)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , FALSE , _
            FALSE , FALSE , 0 , _
            0 , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = "Remove selected line from the list."
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_COMMAND2 = hWndControl

    '------------------------------------------------------------------------------
    ' Create COMMAND1 [CommandButton] control.
    '------------------------------------------------------------------------------
    hWndControl = CreateWindowEx(WS_EX_LEFT Or WS_EX_LTRREADING , _
            "Button" , _
            "Add File(s) to convert" , _
            WS_CHILD Or WS_VISIBLE Or WS_TABSTOP Or BS_TEXT _
            Or BS_PUSHBUTTON Or BS_NOTIFY Or BS_CENTER Or BS_VCENTER _
             , _
            afxScaleX(136) , afxScaleY(FLY_ClientOffset + 416) , _
            afxScaleX(146) , afxScaleY(38) , _
            hWndForm , Cast(HMENU , Cast(LONG_PTR , IDC_FORM1_COMMAND1)) , _
            App.hInstance , ByVal 0)

    ff = FLY_SetControlData(hWndControl , TRUE , TRUE , _
            "Tahoma,9,0" , 0 , FALSE , _
            FALSE , FALSE , 0 , _
            0 , Cast(HBRUSH , - 1) , Cast(WNDPROC , @FORM1_CODEPROCEDURE) , _
            "" , FALSE)

    ' If this control has a ToolTip specified then set it now
    FLY_zTempString = "Select the files you want to convert to Pdf"
    If Len(FLY_zTempString) then
        FF_AddToolTip hWndControl , FLY_zTempString , FALSE
    End If

    ' Set the Tag properties for the Control
    FF_Control_SetTag hWndControl , ""
    FF_Control_SetTag2 hWndControl , ""

    HWND_FORM1_COMMAND1 = hWndControl


    ' Set focus to the lowest control in the Tab Order
    SetFocus HWND_FORM1_COMMAND6
End Sub




'------------------------------------------------------------------------------
' FORM1_FORMPROCEDURE
'------------------------------------------------------------------------------
Private Function FORM1_FORMPROCEDURE(ByVal hWndForm As HWND , _
            ByVal wMsg As uInteger , _
            ByVal wParam As WPARAM , _
            ByVal lParam As LPARAM _
            ) As LRESULT

    Dim FLY_UserData As Long Ptr
    Dim FLY_pNotify As NMHDR Ptr
    Dim FLY_pTBN As TBNOTIFY Ptr
    Dim FLY_lpToolTip As TOOLTIPTEXT Ptr
    Dim FLY_zTempString As zString * MAX_PATH
    Dim FLY_TCITEM As TC_ITEM
    Dim FLY_bm As Bitmap
    Dim FLY_Rect As Rect
    Dim FLY_TabRect As Rect
    Dim FLY_StatusRect As Rect
    Dim FLY_ToolbarRect As Rect
    Dim FLY_ProcAddress As Long
    Dim FLY_hFont As HFONT
    Dim FLY_hDC As HDC
    Dim FLY_hForeColor As Long
    Dim FLY_hBackBrush As Long
    Dim FLY_hwndParent As HWND
    Dim FLY_nResult As HANDLE
    Dim FLY_tempLong As Long
    Dim FLY_ControlIndex As Long
    Dim FLY_StatusBarHeight As Long
    Dim FLY_ToolBarHeight As Long

    Dim ff As FLY_DATA Ptr
    Dim FLY_control As FLY_DATA Ptr
    If IsWindow(hWndForm) And (wMsg <> WM_CREATE) Then ff = GetProp(hWndForm , "FLY_PTR")


    ' Handle the sizing of any toolbars/statusbars
    If wMsg = WM_SIZE Then



        ' Initialize the resize rules data (if needed)
        EnumChildWindows hWndForm , Cast(WNDENUMPROC , @FLY_ResizeRuleInitEnum) , 0
        If wParam <> SIZE_MINIMIZED Then
            EnumChildWindows hWndForm , Cast(WNDENUMPROC , @FLY_ResizeRuleEnum) , 0
        End If
    End If


    If wMsg = WM_ACTIVATE then
        If wParam = FALSE then
            gFLY_hDlgCurrent = 0
        Else
            gFLY_hDlgCurrent = hWndForm
        End If
    End If


    ' Get the ControlIndex (if any)
    Select Case wMsg
        Case WM_COMMAND , WM_HSCROLL , WM_VSCROLL
            If lParam <> 0 Then FLY_nResult = Cast(HANDLE , lParam)
        Case WM_NOTIFY
            FLY_pNotify = Cast(NMHDR Ptr , lParam)
            If FLY_pNotify -> hWndFrom <> 0 Then FLY_nResult = FLY_pNotify -> hWndFrom
    End Select
    If FLY_nResult Then FLY_control = GetProp(Cast(HWND , FLY_nResult) , "FLY_PTR")
    If FLY_control Then FLY_ControlIndex = FLY_control -> ControlIndex Else FLY_ControlIndex = - 1



    ' The following CASE calls notification events from Controls on the Form and
    ' for any of these messages that the user is handling themselves.
    Select Case wMsg

        Case WM_COMMAND
            If (LoWord(wParam) = IDC_FORM1_COMMAND1) And (HiWord(wParam) = BN_CLICKED) Then
                FLY_tempLong = FORM1_COMMAND1_BN_CLICKED(FLY_ControlIndex , hWndForm , Cast(HWND , lParam) , LoWord(wParam))
                If FLY_tempLong Then Function = FLY_tempLong : Exit Function
            End If
            If (LoWord(wParam) = IDC_FORM1_COMMAND2) And (HiWord(wParam) = BN_CLICKED) Then
                FLY_tempLong = FORM1_COMMAND2_BN_CLICKED(FLY_ControlIndex , hWndForm , Cast(HWND , lParam) , LoWord(wParam))
                If FLY_tempLong Then Function = FLY_tempLong : Exit Function
            End If
            If (LoWord(wParam) = IDC_FORM1_COMMAND3) And (HiWord(wParam) = BN_CLICKED) Then
                FLY_tempLong = FORM1_COMMAND3_BN_CLICKED(FLY_ControlIndex , hWndForm , Cast(HWND , lParam) , LoWord(wParam))
                If FLY_tempLong Then Function = FLY_tempLong : Exit Function
            End If
            If (LoWord(wParam) = IDC_FORM1_COMMAND4) And (HiWord(wParam) = BN_CLICKED) Then
                FLY_tempLong = FORM1_COMMAND4_BN_CLICKED(FLY_ControlIndex , hWndForm , Cast(HWND , lParam) , LoWord(wParam))
                If FLY_tempLong Then Function = FLY_tempLong : Exit Function
            End If
            If (LoWord(wParam) = IDC_FORM1_COMMAND5) And (HiWord(wParam) = BN_CLICKED) Then
                FLY_tempLong = FORM1_COMMAND5_BN_CLICKED(FLY_ControlIndex , hWndForm , Cast(HWND , lParam) , LoWord(wParam))
                If FLY_tempLong Then Function = FLY_tempLong : Exit Function
            End If
            If (LoWord(wParam) = IDC_FORM1_COMMAND6) And (HiWord(wParam) = BN_CLICKED) Then
                FLY_tempLong = FORM1_COMMAND6_BN_CLICKED(FLY_ControlIndex , hWndForm , Cast(HWND , lParam) , LoWord(wParam))
                If FLY_tempLong Then Function = FLY_tempLong : Exit Function
            End If
			If (LoWord(wParam) = IDC_FORM1_COMMAND7) And (HiWord(wParam) = BN_CLICKED) Then
                FLY_tempLong = FORM1_COMMAND7_BN_CLICKED(FLY_ControlIndex , hWndForm , Cast(HWND , lParam) , LoWord(wParam))
                If FLY_tempLong Then Function = FLY_tempLong : Exit Function
            End If

        Case WM_HSCROLL


        Case WM_VSCROLL


        Case WM_NOTIFY

    End Select

    ' Handle any custom messages if necessary.

    ' The following CASE processes the internal FireFly requirements
    Select Case wMsg

        Case WM_GETMINMAXINFO
            ' Do not process this message for MDI Child forms because it will interfere
            ' with the maximizing of the child form.
            If (GetWindowLongPtr(hWndForm , GWL_EXSTYLE) And WS_EX_MDICHILD) <> WS_EX_MDICHILD Then
                DefWindowProc hWndForm , wMsg , wParam , lParam
                Dim FLY_pMinMaxInfo As MINMAXINFO Ptr
                FLY_pMinMaxInfo = Cast(MINMAXINFO Ptr , lParam)
                FLY_pMinMaxInfo -> ptMinTrackSize.x = FLY_pMinMaxInfo -> ptMinTrackSize.x
                FLY_pMinMaxInfo -> ptMinTrackSize.y = FLY_pMinMaxInfo -> ptMinTrackSize.y
                FLY_pMinMaxInfo -> ptMaxTrackSize.x = FLY_pMinMaxInfo -> ptMaxTrackSize.x
                FLY_pMinMaxInfo -> ptMaxTrackSize.y = FLY_pMinMaxInfo -> ptMaxTrackSize.y
                Function = 0 : Exit Function
            End If

        Case WM_SYSCOMMAND
            If (wParam And &HFFF0) = SC_CLOSE Then
                SendMessage hWndForm , WM_CLOSE , wParam , lParam
                Exit Function
            End If

        Case WM_SETFOCUS
            ' Set the focus back to the correct child control.
            If ff Then SetFocus ff -> CtrlFocus

        Case WM_SYSCOLORCHANGE , WM_THEMECHANGED
            ' Re-create any background brushes for the Controls on the Form.
            EnumChildWindows hWndForm , Cast(WNDENUMPROC , @FLY_EnumSysColorChangeProc) , 0

            ' Forward this message to any Common Controls because they do not automatically
            ' receive this message.

        Case WM_NOTIFY

        Case WM_CLOSE
            ' If we are dealing with a modal Form then it is important to re-enable the
            ' parent form and make it active prior to this form being destroyed.
            If ff Then
                If ff -> IsModal Then
                    ' Reset the focus back to the parent of the modal form.
                    ' Enable Mouse and keyboard input for the Parent Form
                    EnableWindow ff -> hWndParent , TRUE
                    SetActiveWindow ff -> hWndParent
                    ShowWindow hWndForm , SW_HIDE
                End If
            End If
        Case WM_DESTROY

            ' Delete any user defined Timer controls
            HWND_FORM1 = 0

            ' Delete the Fonts/Brushes used for this form/control and its associated property
            If ff Then
                If ff -> hBackBrush Then DeleteObject(Cast(HGDIOBJ , ff -> hBackBrush))

                ' Destroy the Accelerator Table if it was created
                If ff -> hAccel Then DestroyAcceleratorTable ff -> hAccel
                If ff -> hStatusBarTimer Then KillTimer ByVal 0 , ff -> hStatusBarTimer

                ' Re-claim the memory used by the type structure
                HeapFree GetProcessHeap() , 0 , ByVal Cast(PVOID , ff)

                ' Remove font from global array
                For x As Long = LBound(gFLY_FontHandles) To Ubound(gFLY_FontHandles)
                    If gFLY_FontHandles(x) = ff -> hFont Then
                        gFLY_FontHandles(x) = 0 : Exit For
                    End If
                Next

                ' Remove the property holding the Tag property string.
                FLY_nResult = GetProp(hWndForm , "FLY_TAGPROPERTY")
                If FLY_nResult Then
                    HeapFree GetProcessHeap() , 0 , ByVal Cast(PVOID , FLY_nResult)
                    RemoveProp hWndForm , "FLY_TAGPROPERTY"
                End If
                FLY_nResult = GetProp(hWndForm , "FLY_TAGPROPERTY2")
                If FLY_nResult Then
                    HeapFree GetProcessHeap() , 0 , ByVal Cast(PVOID , FLY_nResult)
                    RemoveProp hWndForm , "FLY_TAGPROPERTY2"
                End If

            End If
            RemoveProp hWndForm , "FLY_PTR"
            PostQuitMessage 0
            Function = 0 : Exit Function

        Case WM_CREATE
            ff = HeapAlloc(GetProcessHeap() , HEAP_ZERO_MEMORY , SizeOf(*ff))
            If ff Then
                SetProp hWndForm , "FLY_PTR" , ff' Store the pointer for later use
                ff -> IsForm = TRUE              ' This is a Form, not a Control.
            Else
                Function = - 1 : Exit Function   ' Return -1 to break the action
            End If

            ' Retrieve any user defined value that was passed via the Show function.
            FLY_UserData = Cast(Long Ptr , lParam)


            ' Set the Shared variable for this Form.
            HWND_FORM1 = hWndForm

            ' Set the Tag properties for the Form
            FF_Control_SetTag hWndForm , ""
            FF_Control_SetTag2 hWndForm , ""

            FORM1_CreateControls hWndForm

            ' Create the Keyboard accelerator if necessary

            ' The MDIClient (if applicatable) is being created, but not yet shown. Allow the user
            ' to process their commands prior to showing it.

            ' The form is being created, but not yet shown. Allow the user to process their
            ' commands prior to showing the Form's controls.
            FLY_tempLong = FORM1_WM_CREATE(hWndForm , *FLY_UserData)
            If FLY_tempLong Then Function = FLY_tempLong : Exit Function

            ' Create any user defined Timer controls

        Case WM_ERASEBKGND

        Case WM_TIMER

        Case WM_CTLCOLOREDIT , _
                    WM_CTLCOLORLISTBOX , _
                    WM_CTLCOLORSTATIC , _
                    WM_CTLCOLORBTN

            ' Message received from child control about to display.
            ' Set the Color properties here.
            ' lParam is the handle of the Control. wParam is the hDC.
            FLY_hDC = Cast(HDC , wParam)

            FLY_control = GetProp(Cast(HWND , lParam) , "FLY_PTR")
            If FLY_control = 0 Then
                FLY_control = GetProp(GetFocus() , "FLY_PTR")
                If FLY_control = 0 Then Exit Select
            End If

            If FLY_control -> ProcessCtlColor Then

                SetTextColor FLY_hDC , IIF(FLY_control -> IsForeSysColor , GetSysColor(FLY_control -> nForeColor) , FLY_control -> nForeColor)
                SetBkColor FLY_hDC , IIF(FLY_control -> IsBackSysColor , GetSysColor(FLY_control -> nBackColor) , FLY_control -> nBackColor)

                ' If this is a TextBox then we must use the OPAQUE STYLE, otherwise
                ' we will get a lot of screen garbage in the control when scrolling.
                GetClassName FLY_control -> hWndControl , FLY_zTempString , SizeOf(FLY_zTempString)

                ' Return the handle of the brush used to paint the background
                Function = Cast(LRESULT , FLY_control -> hBackBrush)

                If UCase(FLY_zTempString) = "EDIT" Then
                    SetBkMode FLY_hDC , OPAQUE

                    ' If the control is disabled then attempt to use the disabled color
                    If IsWindowEnabled(Cast(HWND , lParam)) = FALSE Then
                        SetBkColor FLY_hDC , GetSysColor(COLOR_BTNFACE)
                        Function = Cast(LRESULT , GetSysColorBrush(COLOR_BTNFACE))
                    End If

                Else
                    SetBkMode FLY_hDC , TRANSPARENT
                End If
                Exit Function
            End If
    End Select

    Function = DefWindowProc(hWndForm , wMsg , wParam , lParam)
End Function



'------------------------------------------------------------------------------
' FORM1_CODEPROCEDURE
'------------------------------------------------------------------------------
Private Function FORM1_CODEPROCEDURE(ByVal hWndControl As HWND , _
            ByVal wMsg As uInteger , _
            ByVal wParam As WPARAM , _
            ByVal lParam As LPARAM _
            ) As LRESULT

    ' All messages for every control on the the FORM1 form are processed
    ' in this function.

    Dim FLY_ProcAddress As WNDPROC
    Dim FLY_hFont As HFONT
    Dim FLY_hBackBrush As Long
    Dim FLY_nResult As HANDLE
    Dim FLY_tempLong As Long
    Dim FLY_TopForm As Long
    Dim FLY_ControlIndex As Long
    Dim FLY_TCITEM As TC_ITEM
    Dim uVersion As OSVERSIONINFO
    Dim FLY_zTempString As zString * MAX_PATH
    Dim FLY_Rect As Rect

    Dim ff As FLY_DATA Ptr
    Dim FLY_parent As FLY_DATA Ptr
    If hWndControl Then ff = GetProp(hWndControl , "FLY_PTR")
    If ff Then FLY_ControlIndex = ff -> ControlIndex Else FLY_ControlIndex = - 1


    ' The following CASE processes the internal FireFly requirements prior
    ' to processing the user-defined events (These are handled in a
    ' separate CASE following this one).
    Select Case wMsg
        Case WM_DESTROY
            ' Unsublass the Control
            If ff Then

                ' Delete the brushes used for this Control
                If ff -> hBackBrush Then DeleteObject(Cast(HGDIOBJ , ff -> hBackBrush))

                FLY_ProcAddress = ff -> OldProc

                ' Re-claim the memory used by the type structure
                If ff Then HeapFree(GetProcessHeap() , 0 , ByVal Cast(PVOID , ff))
                RemoveProp hWndControl , "FLY_PTR"

                ' Remove the properties holding the Tag property strings.
                FLY_nResult = GetProp(hWndControl , "FLY_TAGPROPERTY")
                If FLY_nResult Then
                    HeapFree GetProcessHeap() , 0 , ByVal Cast(PVOID , FLY_nResult)
                    RemoveProp hWndControl , "FLY_TAGPROPERTY"
                End If
                FLY_nResult = GetProp(hWndControl , "FLY_TAGPROPERTY2")
                If FLY_nResult Then
                    HeapFree GetProcessHeap() , 0 , ByVal Cast(PVOID , FLY_nResult)
                    RemoveProp hWndControl , "FLY_TAGPROPERTY2"
                End If

                DeleteObject ff -> hFont

                ' Allow the WM_DESTROY message to be processed by the control.
                SetWindowLongPtr hWndControl , GWLP_WNDPROC , Cast(LONG_PTR , FLY_ProcAddress)
                CallWindowProc Cast(WNDPROC , FLY_ProcAddress) , hWndControl , wMsg , wParam , lParam

            End If

            Function = 0 : Exit Function

        Case WM_SETFOCUS
            ' If this is a TextBox, we check to see if we need to highlight the text.
            If ff Then
                If ff -> SelText Then
                    SendMessage hWndControl , EM_SETSEL , 0 , - 1
                Else
                    SendMessage hWndControl , EM_SETSEL , - 1 , 0
                End If
            End If

            ' Store the focus control in the parent form
            ' If this Form is a TabControl child Form then we need to store the CtrlFocus
            ' in the parent of this child Form.
            FLY_tempLong = GetWindowLongPtr(GetParent(hWndControl) , GWL_STYLE)
            If (FLY_tempLong And WS_CHILD) = WS_CHILD Then
                ' must be a TabControl child dialog
                FLY_parent = GetProp(GetParent(GetParent(hWndControl)) , "FLY_PTR")
            Else
                FLY_parent = GetProp(GetParent(hWndControl) , "FLY_PTR")
            End If
            If FLY_parent Then FLY_parent -> CtrlFocus = hWndControl


        Case WM_SIZE , WM_MOVE
            ' Handle any TabControl child pages that are autosize. If the TabControl changes
            ' size then it is caught here. We only need to deal with TabControlChildAutoSize
            ' forms because other forms stay at the fixed size.


    End Select


    ' The following case calls each user defined function.
    Select Case wMsg

        Case 0

    End Select

    ' Handle any custom messages if necessary.


    ' This control is subclassed, therefore we must send all unprocessed messages
    ' to the original window procedure.
    Function = CallWindowProc(ff -> OldProc , hWndControl , wMsg , wParam , lParam)

End Function




'--------------------------------------------------------------------------------
Private Function FORM1_WM_CREATE(ByVal hWndForm as HWnd , _ ' handle of Form
            ByVal UserData as Long _                     ' optional user defined value
            ) as Long

    If extended = 999 Then FF_Control_ShowState(HWND_FORM1_COMMAND6 , SW_SHOW)
    Dim lv as HWnd = HWND_FORM1_LISTVIEW1

    FF_ListView_InsertColumn lv , 0 , "Source File(s) to convert" , LVCFMT_LEFT , 480
    FF_ListView_InsertColumn lv , 1 , "Destination for converted Pdf File(s)" , LVCFMT_LEFT , 480
    FF_ListView_InsertColumn lv , 2 , "Status" , LVCFMT_LEFT , 60

    #IfDef __FB_64BIT__
        FF_Control_SetText(hWndForm , FF_Control_GetText(hWndForm) & "  (64bits)")
    #Else
        FF_Control_SetText(hWndForm , FF_Control_GetText(hWndForm) & "  (32bits)")
    #EndIf

    Function = 0                                 ' change according to your needs
End Function


'--------------------------------------------------------------------------------



'--------------------------------------------------------------------------------
Function FORM1_COMMAND1_BN_CLICKED( _
            ByVal ControlIndex as Long , _               ' index in Control Array
            ByVal hWndForm as HWnd , _                   ' handle of Form
            ByVal hWndControl as HWnd , _                ' handle of Control
            ByVal idButtonControl as Long _              ' identifier of button
            ) as Long

    Dim as String sFilename                      ' Or OFN_NOCHANGEDIR Or OFN_ALLOWMULTISELECT
    If FF_OpenFileDialog(hWndForm , "Select files to convert" , sFilename , _
            Exepath() , _
            "All Files (*.*)|*.*" , _
            "" , _
            OFN_ALLOWMULTISELECT Or OFN_FILEMUSTEXIST Or OFN_EXPLORER Or OFN_NOCHANGEDIR , _
            False) Then
        fill_array(sFilename)
        ' MessageBox(0, sFilename ,"Files selected",0)
    End If
    Function = 0                                 ' change according to your needs
End Function

'--------------------------------------------------------------------------------
Private Function fill_array(ByRef s0 as String) as Long
    Dim as String sFilename = FF_Replace(s0 , Chr(0) , Chr(10))
    Dim j as Long = InStr(sFilename , Chr(10))
    Dim k as Long = 1
    Dim i as Long = 2
    Dim v as Long
    Dim as String mess1
    Dim as String mess2
    If j Then
        mess1 = FF_Parse(sFilename , Chr(10) , 1)
        If Right(mess1 , 1) <> "\" Then mess1 &= "\"
        Do While j <> 0
            j = InStr(j + 1 , sFilename , Chr(10))
            If j Then k += 1
            mess2 &= (mess1 & FF_Parse(sFilename , Chr(10) , i) & Chr(10))
            i += 1
        Loop
        sFilename = mess2
    End If

    Dim lv as HWnd = HWND_FORM1_LISTVIEW1
    i = FF_ListView_GetItemCount(lv)
	Dim ipos as Long
	If k = 1 Then
        mess1 = FF_FilePath(s0)
        If Right(mess1 , 1) <> "\" Then mess1 &= "\"
        mess2 = my_OnlyName(FF_FileName(s0))
        ipos = FF_ListView_InsertItem(lv , i + 1 , 0 , s0)
        FF_ListView_SetItemText(lv , ipos , 1 , mess1 & mess2 & ".pdf")
        FF_ListView_SetItemText(lv , ipos , 2 , "  --")
    Else
        For j = 1 To k
            mess2 = FF_Parse(s0 , Chr(0) , j + 1)
			mess2 = my_OnlyName(mess2)
            ipos = FF_ListView_InsertItem(lv , i + j , 0 , mess1 & FF_Parse(s0 , Chr(0) , j + 1))
            FF_ListView_SetItemText(lv , ipos , 1 , mess1 & mess2 & ".pdf")
            FF_ListView_SetItemText(lv , ipos , 2 , "  --")
        Next
    End If


 /'     Dim ipos as Long
    If k = 1 Then
        mess1 = FF_FilePath(s0)
        If Right(mess1 , 1) <> "\" Then mess1 &= "\"
        mess2 = FF_FileName(s0)
        v = InStrRev(mess2 , ".")
        If v Then
            mess2[v - 1] = 95
        Else
            mess2 &= "_xxx"
        End If
        ipos = FF_ListView_InsertItem(lv , i + 1 , 0 , s0)
        FF_ListView_SetItemText(lv , ipos , 1 , mess1 & mess2 & ".pdf")
        FF_ListView_SetItemText(lv , ipos , 2 , "  --")
    Else
        For j = 1 To k
            mess2 = FF_Parse(s0 , Chr(0) , j + 1)

            v = InStrRev(mess2 , ".")
            If v Then
                mess2[v - 1] = 95
            Else
                mess2 &= "_xxx"
            End If

            ipos = FF_ListView_InsertItem(lv , i + j , 0 , mess1 & FF_Parse(s0 , Chr(0) , j + 1))
            FF_ListView_SetItemText(lv , ipos , 1 , mess1 & mess2 & ".pdf")
            FF_ListView_SetItemText(lv , ipos , 2 , "  --")
        Next
    End If '/
    unselect()
    s0 = sFilename
    Return k
End Function

'--------------------------------------------------------------------------------
Private Function FORM1_COMMAND2_BN_CLICKED( _
            ByVal ControlIndex as Long , _               ' index in Control Array
            ByVal hWndForm as HWnd , _                   ' handle of Form
            ByVal hWndControl as HWnd , _                ' handle of Control
            ByVal idButtonControl as Long _              ' identifier of button
            ) as Long
    Dim lv as HWnd = HWND_FORM1_LISTVIEW1
    If FF_ListView_GetItemCount(lv) < 1 Then
        Function = 0
        MessageBox hWndForm , Chr(10 , 10) & "Nothing in the list!" , "Information" , MB_OK + MB_ICONINFORMATION Or MB_SYSTEMMODAL
        Exit Function
    End If
    If FF_ListView_GetSelectedItem(lv) <> - 1 Then
        FF_ListView_DeleteItem(lv , FF_ListView_GetSelectedItem(lv))
        unselect()
    Else
        MessageBox hWndForm , Chr(10 , 10) & "Please select a line!" , "Information" , MB_OK + MB_ICONINFORMATION Or MB_SYSTEMMODAL
    End If
    Function = 0                                 ' change according to your needs
End Function

'--------------------------------------------------------------------------------
Private Function FORM1_COMMAND3_BN_CLICKED( _
            ByVal ControlIndex as Long , _               ' index in Control Array
            ByVal hWndForm as HWnd , _                   ' handle of Form
            ByVal hWndControl as HWnd , _                ' handle of Control
            ByVal idButtonControl as Long _              ' identifier of button
            ) as Long
    Dim lv as HWnd = HWND_FORM1_LISTVIEW1
    If FF_ListView_GetItemCount(lv) < 1 Then
        Function = 0
        MessageBox hWndForm , Chr(10 , 10) & "Nothing in the list!" , "Information" , MB_OK + MB_ICONINFORMATION Or MB_SYSTEMMODAL
        Exit Function
    End If
    FF_ListView_DeleteAllItems(lv)
    FF_ListView_SetSelectedItem(lv , - 1)
    Function = 0                                 ' change according to your needs
End Function


'--------------------------------------------------------------------------------
Function FORM1_COMMAND4_BN_CLICKED( _
            ByVal ControlIndex as Long , _               ' index in Control Array
            ByVal hWndForm as HWnd , _                   ' handle of Form
            ByVal hWndControl as HWnd , _                ' handle of Control
            ByVal idButtonControl as Long _              ' identifier of button
            ) as Long
    Dim lv as HWnd = HWND_FORM1_LISTVIEW1


    Dim k as Long = FF_ListView_GetItemCount(lv)
    If k < 1 Then
        MessageBox hWndForm , Chr(10 , 10) & "Please add source file(s) to list before!" , "Information" , MB_OK + MB_ICONINFORMATION Or MB_SYSTEMMODAL
        Function = 0
        Exit Function
    End If
    Dim i as Long
    Dim as long sret
    For i = 0 To k - 1
        If FF_ListView_GetItemText(lv , i , 2) = "  --" or FF_ListView_GetItemText(lv , i , 2) = "Failed" Then
            FF_Control_SetText(HWND_FORM1_LABEL1 , "doing ...  " & FF_ListView_GetItemText(lv , i , 0))
            sret = print2Pdf(FF_ListView_GetItemText(lv , i , 0) , FF_ListView_GetItemText(lv , i , 1) , 0, 0)
            If sret = 0 Then
                FF_ListView_SetItemText(lv , i , 2 , "Done")
            ElseIf sret = 6 Then
                FF_ListView_SetItemText(lv , i , 2 , "Existing")
			ElseIf sret = 8 Then
                FF_ListView_SetItemText(lv , i , 2 , "Wrong")
			ElseIf sret = 9 Then
                FF_ListView_SetItemText(lv , i , 2 , "Is Pdf")
            Else
                FF_ListView_SetItemText(lv , i , 2 , "Failed")
            End If
            FF_Control_Redraw(lv)
        End If
    Next
    FF_Control_SetText(HWND_FORM1_LABEL1 , "")
    unselect()

    Function = 0                                 ' change according to your needs
End Function


Private Sub unselect()
    Dim lv as HWnd = HWND_FORM1_LISTVIEW1
    Dim i as Long = FF_ListView_GetItemCount(lv)
    Dim ipos as Long = FF_ListView_InsertItem(lv , i + 1 , 0 , "")
    FF_ListView_SetSelectedItem(lv , ipos)
    FF_ListView_DeleteItem(lv , ipos)
    FF_ListView_SetSelectedItem(lv , - 1)
End Sub

'--------------------------------------------------------------------------------
Private Function FORM1_COMMAND5_BN_CLICKED( _
            ByVal ControlIndex as Long , _               ' index in Control Array
            ByVal hWndForm as HWnd , _                   ' handle of Form
            ByVal hWndControl as HWnd , _                ' handle of Control
            ByVal idButtonControl as Long _              ' identifier of button
            ) as Long
    Dim lv as HWnd = HWND_FORM1_LISTVIEW1
    If FF_ListView_GetItemCount(lv) < 1 Then
        Function = 0
        MessageBox hWndForm , Chr(10 , 10) & "Nothing in the list!" , "Information" , MB_OK + MB_ICONINFORMATION Or MB_SYSTEMMODAL
        Exit Function
    End If
    Dim as long sret
    Dim k as Long = FF_ListView_GetSelectedItem(lv)
    If k <> - 1 And (FF_ListView_GetItemText(lv , k , 2) = "Existing") Then
        Select Case MessageBox(hWndForm , "" + Chr(10 , 10 , 10) + "Warning, this will overwrite the destination existing file! " + Chr(10 , 10) + "Are you sure, you want to replace that file?" , "Win2Pdf" , _
                        MB_YESNO Or MB_ICONQUESTION Or MB_DEFBUTTON2 Or MB_SYSTEMMODAL)
            Case IDYES
                sret = Print2Pdf(FF_ListView_GetItemText(lv , k , 0) , FF_ListView_GetItemText(lv , k , 1) , 0, 2)
                If sret = 0 Then
                    FF_ListView_SetItemText(lv , k , 2 , "Forced")
                ElseIf sret = 6 Then
                    FF_ListView_SetItemText(lv , k , 2 , "Existing")
				ElseIf sret = 8 Then
                    FF_ListView_SetItemText(lv , k , 2 , "Wrong")
				ElseIf sret = 9 Then
                    FF_ListView_SetItemText(lv , k , 2 , "Is Pdf")
                Else
                    FF_ListView_SetItemText(lv , k , 2 , "Failed")
                End If
        End Select
    Else
        MessageBox hWndForm , Chr(10 , 10) & "Please select first a valid line with 'Existing' status!" , "Information" , MB_OK + MB_ICONINFORMATION Or MB_SYSTEMMODAL
    End If
    unselect()
    Function = 0                                 ' change according to your needs
End Function



'--------------------------------------------------------------------------------
Private Function FORM1_COMMAND6_BN_CLICKED( _
            ByVal ControlIndex as Long , _               ' index in Control Array
            ByVal hWndForm as HWnd , _                   ' handle of Form
            ByVal hWndControl as HWnd , _                ' handle of Control
            ByVal idButtonControl as Long _              ' identifier of button
            ) as Long

    Dim lv as HWnd = HWND_FORM1_LISTVIEW1


    Dim k as Long = FF_ListView_GetItemCount(lv)
    If k < 1 Then
        MessageBox hWndForm , Chr(10 , 10) & "Please add source file(s) to list before!" , "Information" , MB_OK + MB_ICONINFORMATION Or MB_SYSTEMMODAL
        Function = 0
        Exit Function
    End If
    Dim i as Long

'    For i = 0 To k - 1
'        FF_ListView_SetItemText(lv , i , 2 , "  --")
'    Next
'    FF_Control_Redraw(lv)
'    unselect()
    Dim as long sret
    For i = 0 To k - 1
		dim as string sstatus = FF_ListView_GetItemText(lv , i , 2)
		if sstatus = "  --" or  sstatus = "Existing" or  sstatus = "Failed" THEN
			FF_Control_SetText(HWND_FORM1_LABEL1 , "doing ...  " & FF_ListView_GetItemText(lv , i , 0))
			sret = print2pdf(FF_ListView_GetItemText(lv , i , 0) , FF_ListView_GetItemText(lv , i , 1) , 0, 2)
			If sret = 0 Then
				if sstatus = "Existing" THEN
					FF_ListView_SetItemText(lv , i , 2 , "Forced")
				else
					FF_ListView_SetItemText(lv , i , 2 , "Done")
                END IF
			ElseIf sret = 6 Then
				FF_ListView_SetItemText(lv , i , 2 , "Existing")
			ElseIf sret = 8 Then
				FF_ListView_SetItemText(lv , i , 2 , "Wrong")
			ElseIf sret = 9 Then
				FF_ListView_SetItemText(lv , i , 2 , "Is Pdf")
			Else
				FF_ListView_SetItemText(lv , i , 2 , "Failed")
			End If
			FF_Control_Redraw(lv)
        END IF
		FF_Control_SetText(HWND_FORM1_LABEL1 , "")
    Next
    FF_Control_Redraw(lv)
	unselect()
    Function = 0                                 ' change according to your needs
End Function

Private Function FORM1_COMMAND7_BN_CLICKED( _
            ByVal ControlIndex as Long , _               ' index in Control Array
            ByVal hWndForm as HWnd , _                   ' handle of Form
            ByVal hWndControl as HWnd , _                ' handle of Control
            ByVal idButtonControl as Long _              ' identifier of button
            ) as Long

    Dim lv as HWnd = HWND_FORM1_LISTVIEW1


    Dim k as Long = FF_ListView_GetItemCount(lv)
    If k < 1 Then
        Function = 0
        Exit Function
    End If
    Dim i as Long

    For i = 0 To k - 1
        FF_ListView_SetItemText(lv , i , 2 , "  --")
    Next
    FF_Control_Redraw(lv)
    unselect()

    Function = 0                                 ' change according to your needs
End Function

Private Function FF_WINMAIN(ByVal hInstance as HINSTANCE , _
            ByVal hPrevInstance as HINSTANCE , _
            ByRef lpCmdLine as String , _
            ByVal iCmdShow as Long) as Long


    ' If this function returns TRUE (non-zero) then the actual WinMain will exit
    ' thus ending the program. You can do program initialization in this function.

    Dim as Ulong u1
    GetVolumeInformation("c:\", Null, 0, @u1, Null, Null, Null, 0)
    If u1 = 580846173 Then extended = 999

    'MessageBox 0, Str(u1) ,"info", 0
    If lpcmdline <> "" Then
        Dim as String ss1 = Command(1)
        Dim as String ss2 = Command(2)
        Dim as Long iflag
        Dim as Long iforce
        If LCase(ss1) = "-x" Then
            extended = 999
            Function = False
            Exit Function
        End If

        If LCase(ss1) = "-f" Then
            ss1 = Command(2)
            ss2 = Command(3)
            iforce = 2
        End If
		if print2pdf(ss1 , ss2 , 1, iforce) = 0 then MessageBox (0 , Chr(10 , 10) & ss1 & Chr(10 , 10) & "Converted! " , "Done" , MB_OK Or MB_SYSTEMMODAL)
        Function = 1
        Exit Function

    End If


    Function = False                             'return TRUE if you want the program to end.

End Function



Private Function FF_PUMPHOOK(ByRef uMsg as Msg) as Long


    ' If this function returns FALSE (zero) then the processing of the regular
    ' FireFly message pump will continue. Returning TRUE (non-zero) will bypass
    ' the regular message pump.

    Function = False                             ' return TRUE if you need to bypass the FireFly message pump

End Function

'[END_PUMPHOOK]


Private Sub FLY_InitializeVariables()
    ' All FireFly variables relating to Forms and Controls are initialized here. This
    ' includes any Control Arrays that have been defined and control identifiers
    ' per the listing in the Declares include file.

    IDC_FORM1_COMMAND6 = 1000
    IDC_FORM1_LABEL1 = 1001
    IDC_FORM1_COMMAND5 = 1002
    IDC_FORM1_LISTVIEW1 = 1003
    IDC_FORM1_COMMAND3 = 1004
    IDC_FORM1_COMMAND4 = 1005
    IDC_FORM1_COMMAND2 = 1006
    IDC_FORM1_COMMAND1 = 1007


End Sub


Private Sub FLY_SetAppVariables()
    ' All FireFly App variables are initialized here. This Type variable provides
    ' easy access to many commonly used FireFly settings.

    Dim zTemp As zString * MAX_PATH
    Dim x As Long

    App.CompanyName = ""
    App.FileDescription = ""
    App.ProductName = ""
    App.LegalCopyright = ""
    App.LegalTrademarks = ""
    App.Comments = ""

    App.ProductMajor = 1
    App.ProductMinor = 0
    App.ProductRevision = 0
    App.ProductBuild = 0

    App.FileMajor = 1
    App.FileMinor = 0
    App.FileRevision = 0
    App.FileBuild = 0

    ' App.hInstance is set in WinMain/LibMain

    ' Retrieve program full path and EXE/DLL name
    GetModuleFileName App.hInstance , zTemp , MAX_PATH

    x = InStr(- 1 , zTemp , Any ":/\")

    If x Then
        App.Path = Left(zTemp , x)
        App.EXEname = Mid(zTemp , x + 1)
    Else
        App.Path = ""
        App.EXEname = zTemp
    End If


    ' The following two arrays are used to allow FireFly to reuse font
    ' handles that are common to one or more Controls. This saves us
    ' from consuming a GDI resource for every created control font.
    ' ReDim gFLY_FontNames(0) As String
    ReDim gFLY_FontHandles(0) As HFONT

End Sub


Private Function FLY_AdjustWindowRect(ByVal hWndForm As HWND , _
            ByVal cxClient As Long , _
            ByVal cyClient As Long _
            ) As Long

    Dim dwStyle As Long
    Dim hMenu As HMENU
    Dim rc As Rect

    If (cxClient <> 0) And (cyClient <> 0) Then
        dwStyle = GetWindowLongPtr(hWndForm , GWL_STYLE)
        rc.Left = 0 : rc.Top = 0 : rc.Right = cxClient : rc.Bottom = cyClient
        hMenu = GetMenu(hWndForm)
        AdjustWindowRectEx VarPtr(rc) , dwStyle ,(hMenu <> 0) , GetWindowLongPtr(hWndForm , GWL_EXSTYLE)
        If (dwStyle and WS_HSCROLL) = WS_HSCROLL Then rc.Bottom = rc.Bottom + GetSystemMetrics(SM_CYHSCROLL)
        If (dwStyle and WS_VSCROLL) = WS_VSCROLL Then rc.Right = rc.Right + GetSystemMetrics(SM_CXVSCROLL)
        SetWindowPos hWndForm , 0 , 0 , 0 , _
                rc.Right - rc.Left , rc.Bottom - rc.Top , _
                SWP_NOZORDER Or SWP_NOMOVE Or SWP_NOACTIVATE
    End If

    Function = 0

End Function



' Enum all child windows of the Form (basically, all Controls) in order to handle
' the WM_SYSCOLORCHANGE message. This will delete existing brushes and recreate
' them using the new system colors.
Private Function FLY_EnumSysColorChangeProc(ByVal hWnd As HWND , ByVal lParam As LPARAM) As Long
    Dim ff As FLY_DATA Ptr

    ff = GetProp(hWnd , "FLY_PTR")
    If ff Then
        If ff -> ProcessCtlColor Then
            ' Create the new colors/brushes if we are using System colors
            If ff -> IsForeSysColor Then ff -> nForeColor = GetSysColor(ff -> nForeColor)
            If ff -> IsBackSysColor Then
                If ff -> hBackBrush Then DeleteObject(Cast(HGDIOBJ , ff -> hBackBrush))
                ff -> hBackBrush = GetSysColorBrush(ff -> nBackColor)
            End If
        End If
    End If

    Function = TRUE
End Function

Private Function FLY_SetControlData(ByVal hWndControl As HWND , _
            ByVal AllowSubclass As Long , _
            ByVal AllowSetFont As Long , _
            ByRef sFontString As String , _
            ByVal nControlIndex As Long , _
            ByVal nProcessColor As Long , _
            ByVal IsForeSysColor As Long , _
            ByVal IsBackSysColor As Long , _
            ByVal nForeColor As Long , _
            ByVal nBackColor As Long , _
            ByVal nTransparentBrush As HBRUSH , _
            ByVal CodeProcedure As WNDPROC , _
            Byref sResizeRules As String , _
            ByVal nFontUpgrade As Long _
            ) As FLY_DATA ptr

    Dim zClassName As zString * 50
    Dim sFont As String
    Dim ff As FLY_DATA Ptr

    ff = HeapAlloc(GetProcessHeap() , HEAP_ZERO_MEMORY , SizeOf(*ff))
    If ff Then
        ' Store the pointer for later use
        SetProp hWndControl , "FLY_PTR" , ff

        ' Subclass the control
        If AllowSubclass = TRUE Then
            ff -> OldProc = Cast(WNDPROC , SetWindowLongPtr(hWndControl , GWLP_WNDPROC , Cast(LONG_PTR , CodeProcedure)))
        End If

        ' Set the Font for this Form/Control
        If AllowSetFont = TRUE Then

            ' FireFly handles two types of font strings. The first is the traditional
            ' logfont string and the second is the simplified PB version. FireFly is moving
            ' towards the simplified version but needs to handle the logfont version
            ' for backwards compatibility.

            ' If the FontUpgrade property is active then we need to replace the FontName
            ' based on the current operating system.
            If nFontUpgrade <> 0 Then
                IF AfxGetWindowsVersion >= 6 THEN' Vista/Windows 7+
                    sFontString = "Segoe UI," & FF_Remain_Internal(sFontString , ",")
                Else
                    sFontString = "Tahoma," & FF_Remain_Internal(sFontString , ",")
                End If
            End If

            ff -> hFont = FF_MakeFontEx_Internal(sFontString)

            If ff -> hFont Then
                SendMessage hWndControl , WM_SETFONT , Cast(WPARAM , ff -> hFont) , True
                If UCase(zClassName) = "SYSDATETIMEPICK32" Then
                    SendMessage hWndControl , DTM_SETMCFONT , Cast(WPARAM , ff -> hFont) , True
                End If
            End If

        End If

        ff -> ControlIndex = nControlIndex
        ff -> IsForm = FALSE
        ff -> hwndControl = hWndControl
        ff -> zConstraints = sResizeRules

        ' Flag to process the WM_CTLCOLOR??? messages.
        ff -> ProcessCtlColor = nProcessColor
        If ff -> ProcessCtlColor Then
            ff -> IsForeSysColor = IsForeSysColor
            ff -> IsBackSysColor = IsBackSysColor
            ff -> nForeColor = nForeColor
            ff -> nBackColor = nBackColor
            ' Create a Brush for painting the background of this Control.
            If nTransparentBrush <> Cast(HBRUSH , - 1) Then
                ff -> hBackBrush = nTransparentBrush
            Else
                ff -> hBackBrush = IIF(ff -> IsBackSysColor , GetSysColorBrush(ff -> nBackColor) , CreateSolidBrush(ff -> nBackColor))
            End If
        End If

    End If

    Function = ff                                ' return the pointer to the data structure

End Function



Private Function FLY_DoMessagePump(ByVal ShowModalFlag As Long , _
            ByVal hWndForm As HWND , _
            ByVal hWndParent As HWND , _
            ByVal nFormShowState As Long , _
            ByVal IsMDIForm As Long _
            ) As HWND

    Dim zTempString As zString * MAX_PATH
    Dim hWndActive As HWND
    Dim msg As MSG
    Dim ff As FLY_DATA Ptr

    ff = GetProp(hWndForm , "FLY_PTR")
    If ff = 0 Then Exit Function


    ' If this is an MDI child form, then it can not be displayed as modal.
    If (GetWindowLongPtr(hWndForm , GWL_EXSTYLE) And WS_EX_MDICHILD) = WS_EX_MDICHILD Then ShowModalFlag = FALSE


    If ShowModalFlag = TRUE Then

        ' Determine the top level window of the active control
        WHILE(GetWindowLongPtr(hWndParent , GWL_STYLE) AND WS_CHILD) <> 0
            hWndParent = GetParent(hWndParent)
            IF (GetWindowLongPtr(hWndParent , GWL_EXSTYLE) AND WS_EX_MDICHILD) <> 0 THEN EXIT WHILE
        WEND

        ' Set property to show that this is a Modal Form. The hWndParent is
        ' stored in a property because that window needs to be re-enabled
        ' prior to modal form being destroyed and exiting the modal message loop.
        ff -> IsModal = TRUE
        ff -> hWndParent = hWndParent

        ' Disable Mouse and keyboard input for the Parent Form
        If hWndParent <> 0 Then EnableWindow(hWndParent , False)

        ShowWindow hWndForm , nFormShowState
        UpdateWindow hWndForm

        ' Main message loop:
        Do While GetMessage(@Msg , 0 , 0 , 0)
            ' Exit the modal message loop if the Form was destroyed (important).
            If IsWindow(hWndForm) = FALSE Then Exit Do
            If msg.message = WM_QUIT Then Exit Do

            If FF_PUMPHOOK(Msg) = 0 Then
                If IsMDIForm = TRUE Then
                    If TranslateMDISysAccel(hWndForm , @Msg) <> 0 Then Continue Do
                End If

                If TranslateAccelerator(hWndForm , ff -> hAccel , @Msg) = 0 Then

                    hWndActive = FLY_GetActiveHandle(gFLY_hDlgCurrent)

                    ' Handle the strange situation where pressing ESCAPE in a multiline
                    ' textbox causes the application to receive a WM_CLOSE that could
                    ' cause an application to terminate. also allow the TAB key to move
                    ' in and out of a multiline textbox.
                    GetClassName GetFocus , zTempString , SizeOf(zTempString)

                    If (hWndActive = 0) Or (IsDialogMessage(hWndActive , @Msg) = 0) Then
                        TranslateMessage @Msg
                        DispatchMessage @Msg
                    End If

                End If
            End If
        Loop

        Function = Cast(HWND , Cast(LONG_PTR , App.ReturnValue))
        App.ReturnValue = 0

    Else
        ShowWindow hWndForm , nFormShowState
        Function = hWndForm
    End If

End Function


Private Function FLY_GetActiveHandle(ByVal hWnd As HWND) as HWND

    Static szClassName As zString * 100

    ' Determine the top level window of the active control
    Do While(GetWindowLongPtr(hWnd , GWL_STYLE) AND WS_CHILD) <> 0
        IF (GetWindowLongPtr(hWnd , GWL_EXSTYLE) AND WS_EX_MDICHILD) <> 0 THEN EXIT DO
        GetClassName hWnd , szClassName , SizeOf(szClassName)
        If Left(szClassName , 5) = "FORM_" Then EXIT DO
        hWnd = GetParent(hWnd)
    loop

    FUNCTION = hWnd

End Function


Private Function FLY_ResizeRuleInitEnum(ByVal hWnd As HWND , ByVal lParam As LPARAM) As Long

    Dim ff As FLY_DATA Ptr

    ff = GetProp(hWnd , "FLY_PTR")
    If ff = 0 Then Function = TRUE : Exit Function

    If ff -> fResizeInit = TRUE Then Function = TRUE : Exit Function

    ' Store form width and height for future reference
    GetClientRect GetParent(hWnd) , Varptr(ff -> rcForm)

    ' Get the control's rectangle and convert it to client coordinates
    GetWindowRect hWnd , Varptr(ff -> rcCtrl)
    MapWindowPoints 0 , GetParent(hWnd) , Cast(LPPOINT , Varptr(ff -> rcCtrl)) , 2

    ff -> fResizeInit = TRUE

    Function = TRUE

End Function



Private Function FLY_ResizeRuleEnum(ByVal hWnd As HWND , ByVal lParam As LPARAM) As Long

    Dim buf(1 To 4) As FLY_RESCALEDATA
    Dim i As Long
    Dim Constr As String
    Dim Constraints As String
    Dim ConstrRef As String
    Dim RefPntPercentage As Single
    Dim ControlName As String
    Dim rc As Rect
    Dim ff As FLY_DATA Ptr

    ff = GetProp(hWnd , "FLY_PTR")

    If ff = 0 Then Function = TRUE : Exit Function
    If ff -> fResizeInit = FALSE Then Function = TRUE : Exit Function

    Constraints = UCase(ff -> zConstraints)
    if Len(Constraints) < 7 Then Function = TRUE : Exit Function

    ' Control was already initialized. Get its initial coordinates to be used for reference.
    ' Store the controls initial coordinates in the calculation buffer.
    ' One entry for every side of the control.
    Buf(1).P_Init = ff -> rcCtrl.Left            ' Left x-coordinate of the control
    Buf(2).P_Init = ff -> rcCtrl.Top             ' Top y-coordinate of the control
    Buf(3).P_Init = ff -> rcCtrl.Right           ' Right x-coordinate of the control
    Buf(4).P_Init = ff -> rcCtrl.Bottom          ' Bottom y-coordinate of the control

    ' Store the form's width and height in the calculation buffer.
    ' One entry for every side of the form
    Buf(1).FormInit = ff -> rcForm.Right         ' For Left x-coordinate of the control
    Buf(2).FormInit = ff -> rcForm.Bottom        ' For Top y-coordinate of the control
    Buf(3).FormInit = ff -> rcForm.Right         ' For Right x-coordinate of the control
    Buf(4).FormInit = ff -> rcForm.Bottom        ' For Bottom y-coordinate of the control


    ' -------------------------------------------------------------------------------
    ' (2) Get current dimensions of form and store the coordinates in a
    ' buffer to be calculated later on
    ' -------------------------------------------------------------------------------
    GetClientRect GetParent(hWnd) , Varptr(rc)
    Buf(1).FormCur = rc.Right                    ' Left x-coordinate
    Buf(2).FormCur = rc.Bottom                   ' Top y-coordinate
    Buf(3).FormCur = rc.Right                    ' Right x-coordinate
    Buf(4).FormCur = rc.Bottom                   ' Bottom y-coordinate


    ' -------------------------------------------------------------------------------
    ' (3) Calculate new control coordinates (for every one of the 4 control sides)
    ' -------------------------------------------------------------------------------
    For i = 1 To 4
        Constr = FF_Parse(Constraints , "," , i)

        Select Case Left(Constr , 1)
            Case "S"                             ' Scaled coordinate
                Buf(i).P_New = Buf(i).P_Init * (Buf(i).FormCur / Buf(i).FormInit)

            Case "F"                             ' Fixed coordinate
                ConstrRef = Mid(Constr , 2)      ' Remove the "F"
                Select Case ConstrRef
                    Case "L" : RefPntPercentage = 0 ' Left side
                    Case "R" : RefPntPercentage = 100 ' Right side
                    Case "T" : RefPntPercentage = 0 ' Top
                    Case "B" : RefPntPercentage = 100 ' Bottom
                    Case Else                    ' Must have been a number
                        RefPntPercentage = Val(ConstrRef)
                End Select

                ' Calc the new position
                Buf(i).P_New = Buf(i).P_Init - _
                        (Buf(i).FormInit * (RefPntPercentage / 100)) + _
                        (Buf(i).FormCur * (RefPntPercentage / 100))

            Case Else
                'MsgBox "Unknown constraint parameter:" & Left$(Constr, 1) & " in " & Constraints
        End Select

    Next


    ' -------------------------------------------------------------------------------
    ' (4) Redraw the control
    ' -------------------------------------------------------------------------------
    SetWindowPos hWnd , 0 , _
            Buf(1).P_New , Buf(2).P_New , _
            Buf(3).P_New - Buf(1).P_New , Buf(4).P_New - Buf(2).P_New , _
            SWP_NOZORDER

    Function = TRUE                              ' Continue enumeration of children

End Function



Private Function WinMain(ByVal hInstance As HINSTANCE , _
            ByVal hPrevInstance As HINSTANCE , _
            ByRef lpCmdLine As String , _
            ByVal iCmdShow As Long _
            ) As Long

    ' Initialize the Common Controls. This is necessary on WinXP platforms in order
    ' to ensure that the XP Theme styles work.
    Dim uCC As INITCOMMONCONTROLSEX

    uCC.dwSize = SizeOf(uCC)
    uCC.dwICC = ICC_NATIVEFNTCTL_CLASS Or ICC_COOL_CLASSES Or ICC_BAR_CLASSES Or _
            ICC_TAB_CLASSES Or ICC_USEREX_CLASSES Or ICC_WIN95_CLASSES Or _
            ICC_STANDARD_CLASSES Or ICC_ANIMATE_CLASS Or ICC_DATE_CLASSES Or _
            ICC_HOTKEY_CLASS Or ICC_INTERNET_CLASSES Or ICC_LISTVIEW_CLASSES Or _
            ICC_PAGESCROLLER_CLASS Or ICC_PROGRESS_CLASS Or ICC_TREEVIEW_CLASSES Or _
            ICC_UPDOWN_CLASS

    InitCommonControlsEx VarPtr(uCC)
    ' Define variable used to uniquely identify this application. This is used
    ' by the FireFly function FF_PrevInstance.
    gFLY_AppID = "FORM_Encrypt_Form1_CLASS"

    ' Define Control Arrays if necessary
    FLY_InitializeVariables

    ' Set the values for the Shared App variable
    App.hInstance = hInstance
    FLY_SetAppVariables

    ' Call the Function FLY_WinMain(). If that function returns True
    ' then cease to continue execution of this program.
    If FF_WINMAIN(hInstance , hPrevInstance , lpCmdLine , iCmdShow) Then
        Function = App.ReturnValue
        Exit Function
    End If

    ' Create the Startup Form.
    Form1_Show 0 , TRUE

    Function = App.ReturnValue

End Function


End WinMain(GetModuleHandle(null) , null , Command() , SW_NORMAL)




